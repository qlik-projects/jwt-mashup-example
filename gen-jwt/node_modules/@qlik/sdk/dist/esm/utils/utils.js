import { CustomError, CustomErrorMsg } from "../errors.js";
import { AuthType } from "../types/types.js";
const getUrl = (host, isSecure = void 0) => {
  let actualHost;
  let actualIsSecure;
  try {
    const url = new URL(host);
    actualHost = url.host + url.pathname;
    actualIsSecure = url.protocol.toLowerCase() === "https:";
  } catch (error) {
    actualHost = host;
    actualIsSecure = isSecure ?? true;
  }
  const urlString = `${actualIsSecure ? "https:" : "http:"}//${actualHost}`.replace(/([^:])(\/\/+)/g, "$1/");
  return new URL(urlString);
};
const validateConfig = (config) => {
  const basicRequiredKeys = ["host", "authType"];
  for (const basicRequiredKey of basicRequiredKeys) {
    if (!(basicRequiredKey in config)) {
      throw new CustomError(
        `${CustomErrorMsg.MISSING_REQUIRED_PROPERTY}: ${basicRequiredKey}`
      );
    }
  }
  if (!config.host || config.host === "") {
    throw new CustomError(CustomErrorMsg.EMPTY_HOST);
  }
  if (!(config.authType in AuthType)) {
    throw new CustomError(
      `${CustomErrorMsg.UNSUPPORTED_AUTH_TYPE}: ${config.authType}`
    );
  }
  const authTypeRequiredKeys = {
    [AuthType.WebIntegration]: ["webIntegrationId"],
    [AuthType.APIKey]: ["apiKey"],
    [AuthType.JWTAuth]: ["fetchToken", "webIntegrationId"],
    [AuthType.OAuth2]: ["clientId"],
    [AuthType.None]: []
  };
  const stringProperties = /* @__PURE__ */ new Set(["webIntegrationId", "apiKey", "clientId", "clientSecret", "redirectUri"]);
  for (const requiredKey of authTypeRequiredKeys[config.authType]) {
    if (!(requiredKey in config) || stringProperties.has(requiredKey) && !config[requiredKey]) {
      throw new CustomError(
        `${CustomErrorMsg.MISSING_REQUIRED_PROPERTY}: ${requiredKey}`
      );
    }
  }
  const authTypeOptionalKeys = {
    [AuthType.APIKey]: ["isSecure"],
    [AuthType.WebIntegration]: ["autoRedirect", "csrfToken", "isSecure"],
    [AuthType.OAuth2]: ["clientSecret", "redirectUri", "scopes", "refreshToken", "isSecure"],
    [AuthType.JWTAuth]: ["csrfToken", "isSecure"]
  };
  const allowedKeys = /* @__PURE__ */ new Set([
    ...basicRequiredKeys,
    ...authTypeRequiredKeys[config.authType],
    ...authTypeOptionalKeys[config.authType] ?? []
  ]);
  for (const configKey of Object.keys(config)) {
    if (!allowedKeys.has(configKey)) {
      throw new CustomError(
        `${CustomErrorMsg.UNSUPPORTED_PROPERTY} ${configKey} for authType ${config.authType}`
      );
    }
  }
  if (config.authType === AuthType.OAuth2) {
    if (!config.clientSecret && !config.redirectUri) {
      throw new CustomError(
        `${CustomErrorMsg.MISSING_REQUIRED_PROPERTY}: clientSecret or redirectUri`
      );
    }
  }
};
const validateProps = (obj, requiredProps) => {
  for (let i = 0; i < requiredProps.length; i += 1) {
    if (!(requiredProps[i] in obj) || obj[requiredProps[i]] === "") {
      throw new CustomError(
        `${CustomErrorMsg.MISSING_REQUIRED_PROPERTY}: ${requiredProps[i]}`
      );
    }
  }
};
const validateClaims = (claims) => {
  const requiredProps = [
    "jti",
    "sub",
    "subType",
    "email",
    "email_verified",
    "groups"
  ];
  validateProps(claims, requiredProps);
};
const validateSigningOptions = (options) => {
  if (options.algorithm !== "RS256" || options.audience !== "qlik.api/login/jwt-session") {
    throw new CustomError(
      `${CustomErrorMsg.MISSING_REQUIRED_PROPERTY}: algorithm and audience missing or must have values 'RS256', respectively 'qlik.api/login/jwt-session'`
    );
  }
  const requiredProps = ["keyid", "issuer", "expiresIn", "notBefore"];
  validateProps(options, requiredProps);
};
const generateRandomString = (length) => {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < length; i += 1) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
};
const isBrowser = (() => typeof window !== "undefined" && ("WebSocket" in window || "MozWebSocket" in window))();
const generateWebsocketUrl = async (appId, rest, config, appendAccessToken = null) => {
  const accessToken = appendAccessToken || isBrowser;
  const hostUrl = getUrl(config.host, config?.isSecure);
  const wssProtocol = hostUrl.protocol === "http:" || hostUrl.protocol === "ws:" ? "ws:" : "wss:";
  const url = `${wssProtocol}//${hostUrl.host}/app/${appId}`;
  if (config.authType === AuthType.APIKey || config.authType === AuthType.OAuth2 && !accessToken) {
    return url;
  }
  if ([AuthType.WebIntegration, AuthType.JWTAuth].includes(config.authType)) {
    let { csrfToken } = config;
    if (!csrfToken) {
      const res = await rest("/csrf-token");
      csrfToken = res.headers.get("qlik-csrf-token");
    }
    const webUrl = `${url}?qlik-csrf-token=${csrfToken}&qlik-web-integration-id=${config.webIntegrationId}`;
    return webUrl;
  }
  if (config.authType === AuthType.OAuth2 && accessToken) {
    const resp = await (await rest("/oauth/token", {
      method: "POST",
      body: JSON.stringify({
        subject_token: config.apiKey,
        subject_token_type: "urn:ietf:params:oauth:token-type:access_token",
        grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
        purpose: "websocket",
        redirect_uri: config.redirectUri,
        client_id: config.clientId
      })
    })).json();
    const webUrl = `${url}?accessToken=${resp.access_token}`;
    return webUrl;
  }
  throw new CustomError(
    `${CustomErrorMsg.NOT_IMPLEMENTED}: function generateWebsocketUrl for AuthType: ${config.authType}`
  );
};
export {
  generateRandomString,
  generateWebsocketUrl,
  getUrl,
  isBrowser,
  validateClaims,
  validateConfig,
  validateSigningOptions
};
