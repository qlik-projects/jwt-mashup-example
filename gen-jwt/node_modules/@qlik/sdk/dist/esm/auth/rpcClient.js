var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/enigma.js/enigma.js
var require_enigma = __commonJS({
  "node_modules/enigma.js/enigma.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.enigma = factory());
    })(exports, function() {
      "use strict";
      var util = {};
      util.isObject = function isObject2(arg) {
        return typeof arg === "object" && arg !== null;
      };
      util.isNumber = function isNumber(arg) {
        return typeof arg === "number";
      };
      util.isUndefined = function isUndefined(arg) {
        return arg === void 0;
      };
      util.isFunction = function isFunction2(arg) {
        return typeof arg === "function";
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      var nodeEventEmitter = EventEmitter;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.init = function() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function(n) {
        if (!util.isNumber(n) || n < 0 || isNaN(n))
          throw TypeError("n must be a positive number");
        this._maxListeners = n;
        return this;
      };
      EventEmitter.prototype.emit = function(type) {
        var er, handler, len, args, i, listeners;
        if (!this._events)
          this._events = {};
        if (type === "error" && !this._events.error) {
          er = arguments[1];
          if (er instanceof Error) {
            throw er;
          } else {
            throw Error('Uncaught, unspecified "error" event.');
          }
        }
        handler = this._events[type];
        if (util.isUndefined(handler))
          return false;
        if (util.isFunction(handler)) {
          switch (arguments.length) {
            case 1:
              handler.call(this);
              break;
            case 2:
              handler.call(this, arguments[1]);
              break;
            case 3:
              handler.call(this, arguments[1], arguments[2]);
              break;
            default:
              len = arguments.length;
              args = new Array(len - 1);
              for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];
              handler.apply(this, args);
          }
        } else if (util.isObject(handler)) {
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          listeners = handler.slice();
          len = listeners.length;
          for (i = 0; i < len; i++)
            listeners[i].apply(this, args);
        }
        return true;
      };
      EventEmitter.prototype.addListener = function(type, listener) {
        var m;
        if (!util.isFunction(listener))
          throw TypeError("listener must be a function");
        if (!this._events)
          this._events = {};
        if (this._events.newListener)
          this.emit(
            "newListener",
            type,
            util.isFunction(listener.listener) ? listener.listener : listener
          );
        if (!this._events[type])
          this._events[type] = listener;
        else if (util.isObject(this._events[type]))
          this._events[type].push(listener);
        else
          this._events[type] = [this._events[type], listener];
        if (util.isObject(this._events[type]) && !this._events[type].warned) {
          var m;
          if (!util.isUndefined(this._maxListeners)) {
            m = this._maxListeners;
          } else {
            m = EventEmitter.defaultMaxListeners;
          }
          if (m && m > 0 && this._events[type].length > m) {
            this._events[type].warned = true;
            if (util.isFunction(console.error)) {
              console.error(
                "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
                this._events[type].length
              );
            }
            if (util.isFunction(console.trace))
              console.trace();
          }
        }
        return this;
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.once = function(type, listener) {
        if (!util.isFunction(listener))
          throw TypeError("listener must be a function");
        var fired = false;
        function g() {
          this.removeListener(type, g);
          if (!fired) {
            fired = true;
            listener.apply(this, arguments);
          }
        }
        g.listener = listener;
        this.on(type, g);
        return this;
      };
      EventEmitter.prototype.removeListener = function(type, listener) {
        var list, position, length, i;
        if (!util.isFunction(listener))
          throw TypeError("listener must be a function");
        if (!this._events || !this._events[type])
          return this;
        list = this._events[type];
        length = list.length;
        position = -1;
        if (list === listener || util.isFunction(list.listener) && list.listener === listener) {
          delete this._events[type];
          if (this._events.removeListener)
            this.emit("removeListener", type, listener);
        } else if (util.isObject(list)) {
          for (i = length; i-- > 0; ) {
            if (list[i] === listener || list[i].listener && list[i].listener === listener) {
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (list.length === 1) {
            list.length = 0;
            delete this._events[type];
          } else {
            list.splice(position, 1);
          }
          if (this._events.removeListener)
            this.emit("removeListener", type, listener);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function(type) {
        var key, listeners;
        if (!this._events)
          return this;
        if (!this._events.removeListener) {
          if (arguments.length === 0)
            this._events = {};
          else if (this._events[type])
            delete this._events[type];
          return this;
        }
        if (arguments.length === 0) {
          for (key in this._events) {
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = {};
          return this;
        }
        listeners = this._events[type];
        if (util.isFunction(listeners)) {
          this.removeListener(type, listeners);
        } else if (Array.isArray(listeners)) {
          while (listeners.length)
            this.removeListener(type, listeners[listeners.length - 1]);
        }
        delete this._events[type];
        return this;
      };
      EventEmitter.prototype.listeners = function(type) {
        var ret;
        if (!this._events || !this._events[type])
          ret = [];
        else if (util.isFunction(this._events[type]))
          ret = [this._events[type]];
        else
          ret = this._events[type].slice();
        return ret;
      };
      EventEmitter.listenerCount = function(emitter, type) {
        var ret;
        if (!emitter._events || !emitter._events[type])
          ret = 0;
        else if (util.isFunction(emitter._events[type]))
          ret = 1;
        else
          ret = emitter._events[type].length;
        return ret;
      };
      var Events = {
        mixin: function mixin(obj) {
          Object.keys(nodeEventEmitter.prototype).forEach(function(key) {
            obj[key] = nodeEventEmitter.prototype[key];
          });
          nodeEventEmitter.init(obj);
        }
      };
      function _typeof$4(obj) {
        "@babel/helpers - typeof";
        return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof$4(obj);
      }
      function _defineProperties$9(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass$9(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties$9(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties$9(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _classCallCheck$9(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits$1(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        Object.defineProperty(subClass, "prototype", { writable: false });
        if (superClass)
          _setPrototypeOf$1(subClass, superClass);
      }
      function _createSuper$1(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf$1(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf$1(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn$1(this, result);
        };
      }
      function _possibleConstructorReturn$1(self2, call) {
        if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
          return call;
        } else if (call !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return _assertThisInitialized$1(self2);
      }
      function _assertThisInitialized$1(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf$1(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
          return _setPrototypeOf$1(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct$1()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf$1(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeReflectConstruct$1() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }
      function _setPrototypeOf$1(o, p) {
        _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf$1(o, p);
      }
      function _getPrototypeOf$1(o) {
        _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf$1(o);
      }
      var EnigmaError = /* @__PURE__ */ function(_Error) {
        _inherits$1(EnigmaError2, _Error);
        var _super = _createSuper$1(EnigmaError2);
        function EnigmaError2(name, code, original) {
          var _this;
          _classCallCheck$9(this, EnigmaError2);
          _this = _super.call(this, name);
          _this.code = code;
          _this.enigmaError = true;
          _this.original = original;
          return _this;
        }
        return _createClass$9(EnigmaError2);
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function createEnigmaError(code, name, original) {
        return new EnigmaError(name, code, original);
      }
      var errorCodes = {
        NOT_CONNECTED: -1,
        OBJECT_NOT_FOUND: -2,
        EXPECTED_ARRAY_OF_PATCHES: -3,
        PATCH_HAS_NO_PARENT: -4,
        ENTRY_ALREADY_DEFINED: -5,
        NO_CONFIG_SUPPLIED: -6,
        PROMISE_REQUIRED: -7,
        SCHEMA_STRUCT_TYPE_NOT_FOUND: -8,
        SCHEMA_MIXIN_CANT_OVERRIDE_FUNCTION: -9,
        SCHEMA_MIXIN_EXTEND_NOT_ALLOWED: -10,
        SESSION_SUSPENDED: -11,
        SESSION_NOT_ATTACHED: -12
      };
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          })), keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {};
          i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck$8(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties$8(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass$8(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties$8(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties$8(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var RPC_CLOSE_NORMAL = 1e3;
      var RPC_CLOSE_MANUAL_SUSPEND$1 = 4e3;
      var cacheId = 0;
      var Session = /* @__PURE__ */ function() {
        function Session2(options) {
          _classCallCheck$8(this, Session2);
          var session = this;
          Object.assign(session, options);
          this.Promise = this.config.Promise;
          this.definition = this.config.definition;
          Events.mixin(session);
          cacheId += 1;
          session.id = cacheId;
          session.rpc.on("socket-error", session.onRpcError.bind(session));
          session.rpc.on("closed", session.onRpcClosed.bind(session));
          session.rpc.on("message", session.onRpcMessage.bind(session));
          session.rpc.on("notification", session.onRpcNotification.bind(session));
          session.rpc.on("traffic", session.onRpcTraffic.bind(session));
          session.on("closed", function() {
            return session.onSessionClosed();
          });
        }
        _createClass$8(Session2, [{
          key: "onRpcError",
          value: function onRpcError(err) {
            if (this.suspendResume.isSuspended) {
              return;
            }
            this.emit("socket-error", err);
          }
        }, {
          key: "onRpcClosed",
          value: function onRpcClosed(evt) {
            var _this = this;
            if (this.suspendResume.isSuspended) {
              return;
            }
            if (evt.code === RPC_CLOSE_NORMAL || evt.code === RPC_CLOSE_MANUAL_SUSPEND$1) {
              return;
            }
            if (this.config.suspendOnClose) {
              var code = evt.code, reason = evt.reason;
              this.suspendResume.suspend().then(function() {
                return _this.emit("suspended", {
                  initiator: "network",
                  code,
                  reason
                });
              });
            } else {
              this.emit("closed", evt);
            }
          }
        }, {
          key: "onRpcMessage",
          value: function onRpcMessage(response) {
            var _this2 = this;
            if (this.suspendResume.isSuspended) {
              return;
            }
            if (response.change) {
              response.change.forEach(function(handle) {
                return _this2.emitHandleChanged(handle);
              });
            }
            if (response.close) {
              response.close.forEach(function(handle) {
                return _this2.emitHandleClosed(handle);
              });
            }
          }
        }, {
          key: "onRpcNotification",
          value: function onRpcNotification(response) {
            this.emit("notification:*", response.method, response.params);
            this.emit("notification:".concat(response.method), response.params);
          }
        }, {
          key: "onRpcTraffic",
          value: function onRpcTraffic(dir, data, handle) {
            this.emit("traffic:*", dir, data);
            this.emit("traffic:".concat(dir), data);
            var api = this.apis.getApi(handle);
            if (api) {
              api.emit("traffic:*", dir, data);
              api.emit("traffic:".concat(dir), data);
            }
          }
        }, {
          key: "onSessionClosed",
          value: function onSessionClosed() {
            this.apis.getApis().forEach(function(entry) {
              entry.api.emit("closed");
              entry.api.removeAllListeners();
            });
            this.apis.clear();
          }
        }, {
          key: "getObjectApi",
          value: function getObjectApi(args) {
            var handle = args.handle, id = args.id, type = args.type, genericType = args.genericType;
            var api = this.apis.getApi(handle);
            if (api) {
              return api;
            }
            var factory = this.definition.generate(type);
            api = factory(this, handle, id, genericType);
            this.apis.add(handle, api);
            return api;
          }
        }, {
          key: "open",
          value: function open() {
            var _this3 = this;
            if (!this.globalPromise) {
              var args = {
                handle: -1,
                id: "Global",
                type: "Global",
                genericType: "Global"
              };
              this.globalPromise = this.rpc.open().then(function() {
                return _this3.getObjectApi(args);
              }).then(function(global) {
                _this3.emit("opened");
                return global;
              });
            }
            return this.globalPromise;
          }
        }, {
          key: "send",
          value: function send(request) {
            var _this4 = this;
            if (this.suspendResume.isSuspended) {
              return this.Promise.reject(createEnigmaError(errorCodes.SESSION_SUSPENDED, "Session suspended", this.rpc.closeEvent));
            }
            request.id = this.rpc.createRequestId();
            var promise = this.intercept.executeRequests(this, this.Promise.resolve(request)).then(function(augmentedRequest) {
              var data = _objectSpread(_objectSpread({}, _this4.config.protocol), augmentedRequest);
              delete data.outKey;
              var response = _this4.rpc.send(data);
              augmentedRequest.retry = function() {
                return _this4.send(request);
              };
              return _this4.intercept.executeResponses(_this4, response, augmentedRequest);
            });
            Session2.addToPromiseChain(promise, "requestId", request.id);
            return promise;
          }
        }, {
          key: "suspend",
          value: function suspend() {
            var _this5 = this;
            var code = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 4e3;
            var reason = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            return this.suspendResume.suspend(code, reason).then(function() {
              return _this5.emit("suspended", {
                initiator: "manual",
                code,
                reason
              });
            });
          }
        }, {
          key: "resume",
          value: function resume(onlyIfAttached) {
            var _this6 = this;
            return this.suspendResume.resume(onlyIfAttached).then(function(value) {
              _this6.emit("resumed");
              return value;
            });
          }
        }, {
          key: "close",
          value: function close() {
            var _this7 = this;
            var code = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1e3;
            var reason = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            this.globalPromise = void 0;
            return this.rpc.close(code, reason).then(function(evt) {
              return _this7.emit("closed", evt);
            });
          }
        }, {
          key: "emitHandleChanged",
          value: function emitHandleChanged(handle) {
            var api = this.apis.getApi(handle);
            if (api) {
              api.emit("changed");
            }
          }
        }, {
          key: "emitHandleClosed",
          value: function emitHandleClosed(handle) {
            var api = this.apis.getApi(handle);
            if (api) {
              api.emit("closed");
              api.removeAllListeners();
            }
          }
        }], [{
          key: "addToPromiseChain",
          value: function addToPromiseChain(promise, name, value) {
            promise[name] = value;
            var then = promise.then;
            promise.then = function patchedThen() {
              for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
                params[_key] = arguments[_key];
              }
              var chain = then.apply(this, params);
              Session2.addToPromiseChain(chain, name, value);
              return chain;
            };
          }
        }]);
        return Session2;
      }();
      function _classCallCheck$7(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties$7(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass$7(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties$7(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties$7(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var KeyValueCache = /* @__PURE__ */ function() {
        function KeyValueCache2() {
          _classCallCheck$7(this, KeyValueCache2);
          this.entries = {};
        }
        _createClass$7(KeyValueCache2, [{
          key: "add",
          value: function add(key, entry) {
            key += "";
            if (typeof this.entries[key] !== "undefined") {
              throw createEnigmaError(errorCodes.ENTRY_ALREADY_DEFINED, "Entry already defined with key ".concat(key));
            }
            this.entries[key] = entry;
          }
        }, {
          key: "set",
          value: function set(key, entry) {
            key += "";
            this.entries[key] = entry;
          }
        }, {
          key: "remove",
          value: function remove(key) {
            delete this.entries[key];
          }
        }, {
          key: "get",
          value: function get(key) {
            return this.entries[key];
          }
        }, {
          key: "getAll",
          value: function getAll() {
            var _this = this;
            return Object.keys(this.entries).map(function(key) {
              return {
                key,
                value: _this.entries[key]
              };
            });
          }
        }, {
          key: "getKey",
          value: function getKey(entry) {
            var _this2 = this;
            return Object.keys(this.entries).filter(function(key) {
              return _this2.entries[key] === entry;
            })[0];
          }
        }, {
          key: "clear",
          value: function clear() {
            this.entries = {};
          }
        }]);
        return KeyValueCache2;
      }();
      function _classCallCheck$6(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties$6(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass$6(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties$6(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties$6(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _typeof$3(obj) {
        "@babel/helpers - typeof";
        return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof$3(obj);
      }
      var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
      function toCamelCase(symbol) {
        return symbol.substring(0, 1).toLowerCase() + symbol.substring(1);
      }
      function namedParamFacade(base, defaults) {
        for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          params[_key - 2] = arguments[_key];
        }
        if (params.length === 1 && _typeof$3(params[0]) === "object" && !Array.isArray(params[0])) {
          var valid = Object.keys(params[0]).every(function(key) {
            return hasOwnProperty$1.call(defaults, key);
          });
          if (valid) {
            params = Object.keys(defaults).map(function(key) {
              return params[0][key] || defaults[key];
            });
          }
        }
        return base.apply(this, params);
      }
      var Schema = /* @__PURE__ */ function() {
        function Schema2(config) {
          _classCallCheck$6(this, Schema2);
          this.config = config;
          this.Promise = config.Promise;
          this.schema = config.schema;
          this.mixins = new KeyValueCache();
          this.types = new KeyValueCache();
        }
        _createClass$6(Schema2, [{
          key: "registerMixin",
          value: function registerMixin(_ref) {
            var _this = this;
            var types = _ref.types, type = _ref.type, extend2 = _ref.extend, override = _ref.override, init = _ref.init;
            if (!Array.isArray(types)) {
              types = [types];
            }
            if (type) {
              types.push(type);
            }
            var cached = {
              extend: extend2,
              override,
              init
            };
            types.forEach(function(typeKey) {
              var entryList = _this.mixins.get(typeKey);
              if (entryList) {
                entryList.push(cached);
              } else {
                _this.mixins.add(typeKey, [cached]);
              }
            });
          }
        }, {
          key: "generate",
          value: function generate(type) {
            var entry = this.types.get(type);
            if (entry) {
              return entry;
            }
            if (!this.schema.structs[type]) {
              throw createEnigmaError(errorCodes.SCHEMA_STRUCT_TYPE_NOT_FOUND, "".concat(type, " not found"));
            }
            var factory = this.generateApi(type, this.schema.structs[type]);
            this.types.add(type, factory);
            return factory;
          }
        }, {
          key: "generateApi",
          value: function generateApi(type, schema) {
            var api = /* @__PURE__ */ Object.create({});
            this.generateDefaultApi(api, schema);
            this.mixinType(type, api);
            this.mixinNamedParamFacade(api, schema);
            return function create(session, handle, id, customKey) {
              var _this2 = this;
              var instance = Object.create(api);
              Events.mixin(instance);
              Object.defineProperties(instance, {
                session: {
                  enumerable: true,
                  value: session
                },
                handle: {
                  enumerable: true,
                  value: handle,
                  writable: true
                },
                id: {
                  enumerable: true,
                  value: id
                },
                type: {
                  enumerable: true,
                  value: type
                },
                genericType: {
                  enumerable: true,
                  value: customKey
                }
              });
              var mixinList = this.mixins.get(type) || [];
              if (customKey !== type) {
                this.mixinType(customKey, instance);
                mixinList = mixinList.concat(this.mixins.get(customKey) || []);
              }
              mixinList.forEach(function(mixin) {
                if (typeof mixin.init === "function") {
                  mixin.init({
                    config: _this2.config,
                    api: instance
                  });
                }
              });
              return instance;
            }.bind(this);
          }
        }, {
          key: "generateDefaultApi",
          value: function generateDefaultApi(api, schema) {
            Object.keys(schema).forEach(function(method) {
              var out = schema[method].Out;
              var outKey = out.length === 1 ? out[0].Name : -1;
              var fnName = toCamelCase(method);
              api[fnName] = function generatedMethod() {
                for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  params[_key2] = arguments[_key2];
                }
                return this.session.send({
                  handle: this.handle,
                  method,
                  params,
                  outKey
                });
              };
            });
          }
        }, {
          key: "mixinType",
          value: function mixinType(type, api) {
            var mixinList = this.mixins.get(type);
            if (mixinList) {
              mixinList.forEach(function(_ref2) {
                var _ref2$extend = _ref2.extend, extend2 = _ref2$extend === void 0 ? {} : _ref2$extend, _ref2$override = _ref2.override, override = _ref2$override === void 0 ? {} : _ref2$override;
                Object.keys(override).forEach(function(key) {
                  if (typeof api[key] === "function" && typeof override[key] === "function") {
                    var baseFn = api[key];
                    api[key] = function wrappedFn() {
                      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                        args[_key3] = arguments[_key3];
                      }
                      return override[key].apply(this, [baseFn.bind(this)].concat(args));
                    };
                  } else {
                    throw createEnigmaError(errorCodes.SCHEMA_MIXIN_CANT_OVERRIDE_FUNCTION, "No function to override. Type: ".concat(type, " function: ").concat(key));
                  }
                });
                Object.keys(extend2).forEach(function(key) {
                  if (typeof api[key] === "function" && typeof extend2[key] === "function") {
                    throw createEnigmaError(errorCodes.SCHEMA_MIXIN_EXTEND_NOT_ALLOWED, "Extend is not allowed for this mixin. Type: ".concat(type, " function: ").concat(key));
                  } else {
                    api[key] = extend2[key];
                  }
                });
              });
            }
          }
        }, {
          key: "mixinNamedParamFacade",
          value: function mixinNamedParamFacade(api, schema) {
            Object.keys(schema).forEach(function(key) {
              var fnName = toCamelCase(key);
              var base = api[fnName];
              var defaults = schema[key].In.reduce(function(result, item) {
                result[item.Name] = item.DefaultValue;
                return result;
              }, {});
              api[fnName] = function namedParamWrapper() {
                for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                  params[_key4] = arguments[_key4];
                }
                return namedParamFacade.apply(this, [base, defaults].concat(params));
              };
            });
          }
        }]);
        return Schema2;
      }();
      function _classCallCheck$5(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties$5(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass$5(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties$5(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties$5(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var RPCResolver = /* @__PURE__ */ function() {
        function RPCResolver2(id, handle, resolve, reject) {
          _classCallCheck$5(this, RPCResolver2);
          Events.mixin(this);
          this.id = id;
          this.handle = handle;
          this.resolve = resolve;
          this.reject = reject;
        }
        _createClass$5(RPCResolver2, [{
          key: "resolveWith",
          value: function resolveWith(data) {
            this.resolve(data);
            this.emit("resolved", this.id);
          }
        }, {
          key: "rejectWith",
          value: function rejectWith(err) {
            this.reject(err);
            this.emit("rejected", this.id);
          }
        }]);
        return RPCResolver2;
      }();
      function _classCallCheck$4(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties$4(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass$4(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties$4(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties$4(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var RPC = /* @__PURE__ */ function() {
        function RPC2(options) {
          _classCallCheck$4(this, RPC2);
          Object.assign(this, options);
          Events.mixin(this);
          this.resolvers = {};
          this.requestId = 0;
          this.openedPromise = void 0;
          this.closeEvent = void 0;
        }
        _createClass$4(RPC2, [{
          key: "open",
          value: function open() {
            var _this = this;
            var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            if (!force && this.openedPromise) {
              return this.openedPromise;
            }
            try {
              this.socket = this.createSocket(this.url);
            } catch (err) {
              return this.Promise.reject(err);
            }
            this.socket.onopen = this.onOpen.bind(this);
            this.socket.onclose = this.onClose.bind(this);
            this.socket.onerror = this.onError.bind(this);
            this.socket.onmessage = this.onMessage.bind(this);
            this.openedPromise = new this.Promise(function(resolve, reject) {
              return _this.registerResolver("opened", null, resolve, reject);
            });
            this.closedPromise = new this.Promise(function(resolve, reject) {
              return _this.registerResolver("closed", null, resolve, reject);
            });
            return this.openedPromise;
          }
        }, {
          key: "onOpen",
          value: function onOpen() {
            var _this2 = this;
            this.resolvers.opened.resolveWith(function() {
              return _this2.closedPromise;
            });
          }
        }, {
          key: "onClose",
          value: function onClose(event) {
            this.emit("closed", event);
            this.closeEvent = event;
            if (this.resolvers && this.resolvers.closed) {
              this.resolvers.closed.resolveWith(event);
            }
            this.rejectAllOutstandingResolvers(createEnigmaError(errorCodes.NOT_CONNECTED, "Socket closed", event));
          }
        }, {
          key: "close",
          value: function close() {
            var code = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1e3;
            var reason = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            if (this.socket) {
              this.socket.close(code, reason);
              this.socket = null;
            }
            return this.closedPromise;
          }
        }, {
          key: "onError",
          value: function onError(event) {
            if (this.resolvers.opened) {
              this.resolvers.opened.rejectWith(event);
            } else {
              this.emit("socket-error", event);
            }
            this.rejectAllOutstandingResolvers(createEnigmaError(errorCodes.NOT_CONNECTED, "Socket error", event));
          }
        }, {
          key: "onMessage",
          value: function onMessage(event) {
            var data = JSON.parse(event.data);
            var resolver = this.resolvers[data.id] || {};
            this.emit("traffic", "received", data, resolver.handle);
            if (typeof data.id !== "undefined") {
              this.emit("message", data);
              this.resolvers[data.id].resolveWith(data);
            } else {
              this.emit(data.params ? "notification" : "message", data);
            }
          }
        }, {
          key: "rejectAllOutstandingResolvers",
          value: function rejectAllOutstandingResolvers(reason) {
            var _this3 = this;
            Object.keys(this.resolvers).forEach(function(id) {
              if (id === "opened" || id === "closed") {
                return;
              }
              var resolver = _this3.resolvers[id];
              resolver.rejectWith(reason);
            });
          }
        }, {
          key: "unregisterResolver",
          value: function unregisterResolver(id) {
            var resolver = this.resolvers[id];
            resolver.removeAllListeners();
            delete this.resolvers[id];
          }
        }, {
          key: "registerResolver",
          value: function registerResolver(id, handle, resolve, reject) {
            var _this4 = this;
            var resolver = new RPCResolver(id, handle, resolve, reject);
            this.resolvers[id] = resolver;
            resolver.on("resolved", function(resolvedId) {
              return _this4.unregisterResolver(resolvedId);
            });
            resolver.on("rejected", function(rejectedId) {
              return _this4.unregisterResolver(rejectedId);
            });
          }
        }, {
          key: "send",
          value: function send(data) {
            var _this5 = this;
            if (!this.socket || this.socket.readyState !== this.socket.OPEN) {
              var error = createEnigmaError(errorCodes.NOT_CONNECTED, "Not connected", this.closeEvent);
              return this.Promise.reject(error);
            }
            if (!data.id) {
              data.id = this.createRequestId();
            }
            data.jsonrpc = "2.0";
            return new this.Promise(function(resolve, reject) {
              _this5.socket.send(JSON.stringify(data));
              _this5.emit("traffic", "sent", data, data.handle);
              return _this5.registerResolver(data.id, data.handle, resolve, reject);
            });
          }
        }, {
          key: "createRequestId",
          value: function createRequestId() {
            this.requestId += 1;
            return this.requestId;
          }
        }]);
        return RPC2;
      }();
      function _classCallCheck$3(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties$3(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass$3(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties$3(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties$3(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var ON_ATTACHED_TIMEOUT_MS = 5e3;
      var RPC_CLOSE_MANUAL_SUSPEND = 4e3;
      var SuspendResume = /* @__PURE__ */ function() {
        function SuspendResume2(options) {
          var _this = this;
          _classCallCheck$3(this, SuspendResume2);
          Object.assign(this, options);
          this.isSuspended = false;
          this.rpc.on("traffic", function(dir, data) {
            if (dir === "sent" && data.method === "OpenDoc") {
              _this.openDocParams = data.params;
            }
          });
        }
        _createClass$3(SuspendResume2, [{
          key: "restoreRpcConnection",
          value: function restoreRpcConnection(onlyIfAttached) {
            var _this2 = this;
            return this.reopen(ON_ATTACHED_TIMEOUT_MS).then(function(sessionState) {
              if (sessionState === "SESSION_CREATED" && onlyIfAttached) {
                return _this2.Promise.reject(createEnigmaError(errorCodes.SESSION_NOT_ATTACHED, "Not attached"));
              }
              return _this2.Promise.resolve();
            });
          }
        }, {
          key: "restoreGlobal",
          value: function restoreGlobal(changed) {
            var global = this.apis.getApisByType("Global").pop();
            changed.push(global.api);
            return this.Promise.resolve();
          }
        }, {
          key: "restoreDoc",
          value: function restoreDoc(closed, changed) {
            var _this3 = this;
            var doc = this.apis.getApisByType("Doc").pop();
            if (!doc) {
              return this.Promise.resolve();
            }
            return this.rpc.send({
              method: "GetActiveDoc",
              handle: -1,
              params: []
            }).then(function(response) {
              if (response.error && _this3.openDocParams) {
                return _this3.rpc.send({
                  method: "OpenDoc",
                  handle: -1,
                  params: _this3.openDocParams
                });
              }
              return response;
            }).then(function(response) {
              if (response.error) {
                closed.push(doc.api);
                return _this3.Promise.resolve();
              }
              var handle = response.result.qReturn.qHandle;
              doc.api.handle = handle;
              changed.push(doc.api);
              return _this3.Promise.resolve(doc.api);
            });
          }
        }, {
          key: "restoreDocObjects",
          value: function restoreDocObjects(doc, closed, changed) {
            var _this4 = this;
            var tasks = [];
            var apis = this.apis.getApis().map(function(entry) {
              return entry.api;
            }).filter(function(api) {
              return api.type !== "Global" && api.type !== "Doc";
            });
            if (!doc) {
              apis.forEach(function(api) {
                return closed.push(api);
              });
              return this.Promise.resolve();
            }
            apis.forEach(function(api) {
              var method = SuspendResume2.buildGetMethodName(api.type);
              if (!method) {
                closed.push(api);
              } else {
                var request = _this4.rpc.send({
                  method,
                  handle: doc.handle,
                  params: [api.id]
                }).then(function(response) {
                  if (response.error || !response.result.qReturn.qHandle) {
                    closed.push(api);
                  } else {
                    api.handle = response.result.qReturn.qHandle;
                    changed.push(api);
                  }
                });
                tasks.push(request);
              }
            });
            return this.Promise.all(tasks);
          }
        }, {
          key: "suspend",
          value: function suspend() {
            var code = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RPC_CLOSE_MANUAL_SUSPEND;
            var reason = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            this.isSuspended = true;
            return this.rpc.close(code, reason);
          }
        }, {
          key: "resume",
          value: function resume(onlyIfAttached) {
            var _this5 = this;
            var changed = [];
            var closed = [];
            return this.restoreRpcConnection(onlyIfAttached).then(function() {
              return _this5.restoreGlobal(changed);
            }).then(function() {
              return _this5.restoreDoc(closed, changed);
            }).then(function(doc) {
              return _this5.restoreDocObjects(doc, closed, changed);
            }).then(function() {
              _this5.isSuspended = false;
              _this5.apis.clear();
              closed.forEach(function(api) {
                api.emit("closed");
                api.removeAllListeners();
              });
              changed.forEach(function(api) {
                _this5.apis.add(api.handle, api);
                if (api.type !== "Global") {
                  api.emit("changed");
                }
              });
            })["catch"](function(err) {
              return _this5.rpc.close().then(function() {
                return _this5.Promise.reject(err);
              });
            });
          }
        }, {
          key: "reopen",
          value: function reopen(timeout) {
            var _this6 = this;
            var timer;
            var notificationResolve;
            var notificationReceived = false;
            var notificationPromise = new this.Promise(function(resolve) {
              notificationResolve = resolve;
            });
            var waitForNotification = function waitForNotification2() {
              if (!notificationReceived) {
                timer = setTimeout(function() {
                  return notificationResolve("SESSION_CREATED");
                }, timeout);
              }
              return notificationPromise;
            };
            var onNotification = function onNotification2(data) {
              if (data.method !== "OnConnected")
                return;
              clearTimeout(timer);
              notificationResolve(data.params.qSessionState);
              notificationReceived = true;
            };
            this.rpc.on("notification", onNotification);
            return this.rpc.open(true).then(waitForNotification).then(function(state) {
              _this6.rpc.removeListener("notification", onNotification);
              return state;
            })["catch"](function(err) {
              _this6.rpc.removeListener("notification", onNotification);
              return _this6.Promise.reject(err);
            });
          }
        }], [{
          key: "buildGetMethodName",
          value: function buildGetMethodName(type) {
            if (type === "Field" || type === "Variable") {
              return null;
            }
            if (type === "GenericVariable") {
              return "GetVariableById";
            }
            return type.replace("Generic", "Get");
          }
        }]);
        return SuspendResume2;
      }();
      var SUCCESS_KEY = "qSuccess";
      function deltaRequestInterceptor(session, request) {
        var delta = session.config.protocol.delta && request.outKey !== -1 && request.outKey !== SUCCESS_KEY;
        if (delta) {
          request.delta = delta;
        }
        return request;
      }
      function apiResponseInterceptor(session, request, response) {
        if (response && response.qHandle && response.qType) {
          return session.getObjectApi({
            handle: response.qHandle,
            type: response.qType,
            id: response.qGenericId,
            genericType: response.qGenericType
          });
        }
        if (response && response.qHandle === null && response.qType === null) {
          var error = createEnigmaError(errorCodes.OBJECT_NOT_FOUND, "Object not found");
          return session.config.Promise.reject(error);
        }
        return response;
      }
      var hasOwn = Object.prototype.hasOwnProperty;
      var toStr = Object.prototype.toString;
      var defineProperty = Object.defineProperty;
      var gOPD = Object.getOwnPropertyDescriptor;
      var isArray$1 = function isArray2(arr) {
        if (typeof Array.isArray === "function") {
          return Array.isArray(arr);
        }
        return toStr.call(arr) === "[object Array]";
      };
      var isPlainObject = function isPlainObject2(obj) {
        if (!obj || toStr.call(obj) !== "[object Object]") {
          return false;
        }
        var hasOwnConstructor = hasOwn.call(obj, "constructor");
        var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
          return false;
        }
        var key;
        for (key in obj) {
        }
        return typeof key === "undefined" || hasOwn.call(obj, key);
      };
      var setProperty = function setProperty2(target, options) {
        if (defineProperty && options.name === "__proto__") {
          defineProperty(target, options.name, {
            enumerable: true,
            configurable: true,
            value: options.newValue,
            writable: true
          });
        } else {
          target[options.name] = options.newValue;
        }
      };
      var getProperty = function getProperty2(obj, name) {
        if (name === "__proto__") {
          if (!hasOwn.call(obj, name)) {
            return void 0;
          } else if (gOPD) {
            return gOPD(obj, name).value;
          }
        }
        return obj[name];
      };
      var extend$1 = function extend2() {
        var options, name, src, copy, copyIsArray, clone;
        var target = arguments[0];
        var i = 1;
        var length = arguments.length;
        var deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[1] || {};
          i = 2;
        }
        if (target == null || typeof target !== "object" && typeof target !== "function") {
          target = {};
        }
        for (; i < length; ++i) {
          options = arguments[i];
          if (options != null) {
            for (name in options) {
              src = getProperty(target, name);
              copy = getProperty(options, name);
              if (target !== copy) {
                if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray$1(copy)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && isArray$1(src) ? src : [];
                  } else {
                    clone = src && isPlainObject(src) ? src : {};
                  }
                  setProperty(target, { name, newValue: extend2(deep, clone, copy) });
                } else if (typeof copy !== "undefined") {
                  setProperty(target, { name, newValue: copy });
                }
              }
            }
          }
        }
        return target;
      };
      function _toConsumableArray$1(arr) {
        return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
      }
      function _nonIterableSpread$1() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray$1(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray$1(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray$1(o, minLen);
      }
      function _iterableToArray$1(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _arrayWithoutHoles$1(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray$1(arr);
      }
      function _arrayLikeToArray$1(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _typeof$2(obj) {
        "@babel/helpers - typeof";
        return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof$2(obj);
      }
      var extend = extend$1.bind(null, true);
      var JSONPatch = {};
      var isArray = Array.isArray;
      function isObject(v) {
        return v != null && !Array.isArray(v) && _typeof$2(v) === "object";
      }
      function isUndef(v) {
        return typeof v === "undefined";
      }
      function isFunction(v) {
        return typeof v === "function";
      }
      function generateValue(val) {
        if (val) {
          return extend({}, {
            val
          }).val;
        }
        return val;
      }
      function isSpecialProperty(obj, key) {
        return isFunction(obj[key]) || key.substring(0, 2) === "$$" || key.substring(0, 1) === "_";
      }
      function getParent(data, str) {
        var seperator = "/";
        var parts = str.substring(1).split(seperator).slice(0, -1);
        var numPart;
        parts.forEach(function(part, i) {
          if (i === parts.length) {
            return;
          }
          numPart = +part;
          var newPart = !isNaN(numPart) ? [] : {};
          data[numPart || part] = isUndef(data[numPart || part]) ? newPart : data[part];
          data = data[numPart || part];
        });
        return data;
      }
      function emptyObject(obj) {
        Object.keys(obj).forEach(function(key) {
          var config = Object.getOwnPropertyDescriptor(obj, key);
          if (config.configurable && !isSpecialProperty(obj, key)) {
            delete obj[key];
          }
        });
      }
      function compare(a, b) {
        var isIdentical = true;
        if (isObject(a) && isObject(b)) {
          if (Object.keys(a).length !== Object.keys(b).length) {
            return false;
          }
          Object.keys(a).forEach(function(key) {
            if (!compare(a[key], b[key])) {
              isIdentical = false;
            }
          });
          return isIdentical;
        }
        if (isArray(a) && isArray(b)) {
          if (a.length !== b.length) {
            return false;
          }
          for (var i = 0, l = a.length; i < l; i += 1) {
            if (!compare(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
        return a === b;
      }
      function patchArray(original, newA, basePath) {
        var patches = [];
        var oldA = original.slice();
        var tmpIdx = -1;
        function findIndex(a, id, idx) {
          if (a[idx] && isUndef(a[idx].qInfo)) {
            return null;
          }
          if (a[idx] && a[idx].qInfo.qId === id) {
            return idx;
          }
          for (var ii = 0, ll = a.length; ii < ll; ii += 1) {
            if (a[ii] && a[ii].qInfo.qId === id) {
              return ii;
            }
          }
          return -1;
        }
        if (compare(newA, oldA)) {
          return patches;
        }
        if (!isUndef(newA[0]) && isUndef(newA[0].qInfo)) {
          patches.push({
            op: "replace",
            path: basePath,
            value: newA
          });
          return patches;
        }
        for (var i = oldA.length - 1; i >= 0; i -= 1) {
          tmpIdx = findIndex(newA, oldA[i].qInfo && oldA[i].qInfo.qId, i);
          if (tmpIdx === -1) {
            patches.push({
              op: "remove",
              path: "".concat(basePath, "/").concat(i)
            });
            oldA.splice(i, 1);
          } else {
            patches = patches.concat(JSONPatch.generate(oldA[i], newA[tmpIdx], "".concat(basePath, "/").concat(i)));
          }
        }
        for (var _i = 0, l = newA.length; _i < l; _i += 1) {
          tmpIdx = findIndex(oldA, newA[_i].qInfo && newA[_i].qInfo.qId);
          if (tmpIdx === -1) {
            patches.push({
              op: "add",
              path: "".concat(basePath, "/").concat(_i),
              value: newA[_i]
            });
            oldA.splice(_i, 0, newA[_i]);
          } else if (tmpIdx !== _i) {
            patches.push({
              op: "move",
              path: "".concat(basePath, "/").concat(_i),
              from: "".concat(basePath, "/").concat(tmpIdx)
            });
            oldA.splice(_i, 0, oldA.splice(tmpIdx, 1)[0]);
          }
        }
        return patches;
      }
      JSONPatch.generate = function generate(original, newData, basePath) {
        basePath = basePath || "";
        var patches = [];
        Object.keys(newData).forEach(function(key) {
          var val = generateValue(newData[key]);
          var oldVal = original[key];
          var tmpPath = "".concat(basePath, "/").concat(key);
          if (compare(val, oldVal) || isSpecialProperty(newData, key)) {
            return;
          }
          if (isUndef(oldVal)) {
            patches.push({
              op: "add",
              path: tmpPath,
              value: val
            });
          } else if (isObject(val) && isObject(oldVal)) {
            patches = patches.concat(JSONPatch.generate(oldVal, val, tmpPath));
          } else if (isArray(val) && isArray(oldVal)) {
            patches = patches.concat(patchArray(oldVal, val, tmpPath));
          } else {
            patches.push({
              op: "replace",
              path: "".concat(basePath, "/").concat(key),
              value: val
            });
          }
        });
        Object.keys(original).forEach(function(key) {
          if (isUndef(newData[key]) && !isSpecialProperty(original, key)) {
            patches.push({
              op: "remove",
              path: "".concat(basePath, "/").concat(key)
            });
          }
        });
        return patches;
      };
      JSONPatch.apply = function apply(original, patches) {
        patches.forEach(function(patch) {
          var parent = getParent(original, patch.path);
          var key = patch.path.split("/").splice(-1)[0];
          var target = key && isNaN(+key) ? parent[key] : parent[+key] || parent;
          var from = patch.from ? patch.from.split("/").splice(-1)[0] : null;
          if (patch.path === "/") {
            parent = null;
            target = original;
          }
          if (patch.op === "add" || patch.op === "replace") {
            if (isArray(parent)) {
              if (key === "-") {
                key = parent.length;
              }
              parent.splice(+key, patch.op === "add" ? 0 : 1, patch.value);
            } else if (isArray(target) && isArray(patch.value)) {
              target.length = 0;
              var chunkSize = 1e3;
              for (var i = 0; i < patch.value.length; i += chunkSize) {
                var _target;
                var chunk = patch.value.slice(i, i + chunkSize);
                (_target = target).push.apply(_target, _toConsumableArray$1(chunk));
              }
            } else if (isObject(target) && isObject(patch.value)) {
              emptyObject(target);
              extend(target, patch.value);
            } else if (!parent) {
              throw createEnigmaError(errorCodes.PATCH_HAS_NO_PARENT, "Patchee is not an object we can patch");
            } else {
              parent[key] = patch.value;
            }
          } else if (patch.op === "move") {
            var oldParent = getParent(original, patch.from);
            if (isArray(parent)) {
              parent.splice(+key, 0, oldParent.splice(+from, 1)[0]);
            } else {
              parent[key] = oldParent[from];
              delete oldParent[from];
            }
          } else if (patch.op === "remove") {
            if (isArray(parent)) {
              parent.splice(+key, 1);
            } else {
              delete parent[key];
            }
          }
        });
      };
      JSONPatch.clone = function clone(obj) {
        return extend({}, obj);
      };
      JSONPatch.createPatch = function createPatch(op, val, path) {
        var patch = {
          op: op.toLowerCase(),
          path
        };
        if (patch.op === "move") {
          patch.from = val;
        } else if (typeof val !== "undefined") {
          patch.value = val;
        }
        return patch;
      };
      JSONPatch.updateObject = function updateObject(original, newData) {
        if (!Object.keys(original).length) {
          extend(original, newData);
          return;
        }
        JSONPatch.apply(original, JSONPatch.generate(original, newData));
      };
      function _typeof$1(obj) {
        "@babel/helpers - typeof";
        return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof$1(obj);
      }
      var sessions = {};
      var bindSession = function bindSession2(session) {
        if (!sessions[session.id]) {
          var cache = {};
          sessions[session.id] = cache;
          session.on("traffic:received", function(data) {
            return data.close && data.close.forEach(function(handle) {
              return delete cache[handle];
            });
          });
          session.on("closed", function() {
            return delete sessions[session.id];
          });
        }
      };
      var getHandleCache = function getHandleCache2(session, handle) {
        bindSession(session);
        var cache = sessions[session.id];
        if (!cache[handle]) {
          cache[handle] = new KeyValueCache();
        }
        return cache[handle];
      };
      var patchValue = function patchValue2(session, handle, cacheId2, patches) {
        var cache = getHandleCache(session, handle);
        var entry = cache.get(cacheId2);
        if (typeof entry === "undefined") {
          entry = Array.isArray(patches[0].value) ? [] : {};
        }
        if (patches.length) {
          if (patches[0].path === "/" && _typeof$1(patches[0].value) !== "object") {
            entry = patches[0].value;
          } else {
            JSONPatch.apply(entry, patches);
          }
          cache.set(cacheId2, entry);
        }
        return entry;
      };
      function deltaResponseInterceptor(session, request, response) {
        var delta = response.delta, result = response.result;
        if (delta) {
          Object.keys(result).forEach(function(key) {
            if (!Array.isArray(result[key])) {
              throw createEnigmaError(errorCodes.EXPECTED_ARRAY_OF_PATCHES, "Unexpected RPC response, expected array of patches");
            }
            result[key] = patchValue(session, request.handle, "".concat(request.method, "-").concat(key), result[key]);
          });
          return JSON.parse(JSON.stringify(response));
        }
        return response;
      }
      deltaResponseInterceptor.sessions = sessions;
      function errorResponseInterceptor(session, request, response) {
        if (typeof response.error !== "undefined") {
          var data = response.error;
          var error = new Error(data.message);
          error.code = data.code;
          error.parameter = data.parameter;
          return session.config.Promise.reject(error);
        }
        return response;
      }
      var RETURN_KEY = "qReturn";
      function outParamResponseInterceptor(session, request, response) {
        if (request.method === "CreateSessionApp" || request.method === "CreateSessionAppFromApp") {
          response[RETURN_KEY].qGenericId = response.qSessionAppId || response[RETURN_KEY].qGenericId;
        } else if (request.method === "GetInteract" || request.method === "StoreTempSelectionState" || request.method === "CreateTemporaryBookmark") {
          delete response[RETURN_KEY];
        }
        if (hasOwnProperty.call(response, RETURN_KEY)) {
          return response[RETURN_KEY];
        }
        if (request.outKey !== -1) {
          return response[request.outKey];
        }
        return response;
      }
      function resultResponseInterceptor(session, request, response) {
        return response.result;
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray(arr);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _classCallCheck$2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties$2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass$2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties$2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties$2(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var Intercept = /* @__PURE__ */ function() {
        function Intercept2(options) {
          _classCallCheck$2(this, Intercept2);
          Object.assign(this, options);
          this.request = [{
            onFulfilled: deltaRequestInterceptor
          }].concat(_toConsumableArray(this.request || []));
          this.response = [{
            onFulfilled: errorResponseInterceptor
          }, {
            onFulfilled: deltaResponseInterceptor
          }, {
            onFulfilled: resultResponseInterceptor
          }, {
            onFulfilled: outParamResponseInterceptor
          }].concat(_toConsumableArray(this.response || []), [{
            onFulfilled: apiResponseInterceptor
          }]);
        }
        _createClass$2(Intercept2, [{
          key: "executeRequests",
          value: function executeRequests(session, promise) {
            var _this = this;
            return this.request.reduce(function(interception, interceptor) {
              var intercept = interceptor.onFulfilled && interceptor.onFulfilled.bind(_this, session);
              return interception.then(intercept);
            }, promise);
          }
        }, {
          key: "executeResponses",
          value: function executeResponses(session, promise, request) {
            var _this2 = this;
            return this.response.reduce(function(interception, interceptor) {
              return interception.then(interceptor.onFulfilled && interceptor.onFulfilled.bind(_this2, session, request), interceptor.onRejected && interceptor.onRejected.bind(_this2, session, request));
            }, promise);
          }
        }]);
        return Intercept2;
      }();
      function _typeof(obj) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof(obj);
      }
      function _classCallCheck$1(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties$1(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass$1(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties$1(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties$1(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _get() {
        if (typeof Reflect !== "undefined" && Reflect.get) {
          _get = Reflect.get.bind();
        } else {
          _get = function _get2(target, property, receiver) {
            var base = _superPropBase(target, property);
            if (!base)
              return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
              return desc.get.call(arguments.length < 3 ? target : receiver);
            }
            return desc.value;
          };
        }
        return _get.apply(this, arguments);
      }
      function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
          object = _getPrototypeOf(object);
          if (object === null)
            break;
        }
        return object;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        Object.defineProperty(subClass, "prototype", { writable: false });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        } else if (call !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var ApiCache = /* @__PURE__ */ function(_KeyValueCache) {
        _inherits(ApiCache2, _KeyValueCache);
        var _super = _createSuper(ApiCache2);
        function ApiCache2() {
          _classCallCheck$1(this, ApiCache2);
          return _super.apply(this, arguments);
        }
        _createClass$1(ApiCache2, [{
          key: "add",
          value: function add(handle, api) {
            var _this = this;
            var entry = {
              api
            };
            _get(_getPrototypeOf(ApiCache2.prototype), "add", this).call(this, handle.toString(), entry);
            api.on("closed", function() {
              return _this.remove(handle);
            });
            return entry;
          }
        }, {
          key: "getApi",
          value: function getApi(handle) {
            var entry = typeof handle !== "undefined" ? this.get(handle.toString()) : void 0;
            return entry && entry.api;
          }
        }, {
          key: "getApis",
          value: function getApis() {
            return _get(_getPrototypeOf(ApiCache2.prototype), "getAll", this).call(this).map(function(entry) {
              return {
                handle: entry.key,
                api: entry.value.api
              };
            });
          }
        }, {
          key: "getApisByType",
          value: function getApisByType(type) {
            return this.getApis().filter(function(entry) {
              return entry.api.type === type;
            });
          }
        }]);
        return ApiCache2;
      }(KeyValueCache);
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var Enigma = /* @__PURE__ */ function() {
        function Enigma2() {
          _classCallCheck(this, Enigma2);
        }
        _createClass(Enigma2, null, [{
          key: "getSession",
          value: function getSession(config) {
            var createSocket = config.createSocket, Promise2 = config.Promise, requestInterceptors = config.requestInterceptors, responseInterceptors = config.responseInterceptors, url = config.url;
            var apis = new ApiCache();
            var intercept = new Intercept({
              apis,
              Promise: Promise2,
              request: requestInterceptors,
              response: responseInterceptors
            });
            var rpc = new RPC({
              createSocket,
              Promise: Promise2,
              url
            });
            var suspendResume = new SuspendResume({
              apis,
              Promise: Promise2,
              rpc
            });
            var session = new Session({
              apis,
              config,
              intercept,
              rpc,
              suspendResume
            });
            return session;
          }
        }, {
          key: "configureDefaults",
          value: function configureDefaults(config) {
            if (!config) {
              throw createEnigmaError(errorCodes.NO_CONFIG_SUPPLIED, "You need to supply a configuration.");
            }
            if (!config.Promise && typeof Promise === "undefined") {
              throw createEnigmaError(errorCodes.PROMISE_REQUIRED, "Your environment has no Promise implementation. You must provide a Promise implementation in the config.");
            }
            if (typeof config.createSocket !== "function" && typeof WebSocket === "function") {
              config.createSocket = function(url) {
                return new WebSocket(url);
              };
            }
            if (typeof config.suspendOnClose === "undefined") {
              config.suspendOnClose = false;
            }
            config.protocol = config.protocol || {};
            config.protocol.delta = typeof config.protocol.delta !== "undefined" ? config.protocol.delta : true;
            config.Promise = config.Promise || Promise;
            config.mixins = config.mixins || [];
            config.definition = config.definition || new Schema(config);
          }
        }, {
          key: "create",
          value: function create(config) {
            Enigma2.configureDefaults(config);
            config.mixins.forEach(function(mixin) {
              config.definition.registerMixin(mixin);
            });
            return Enigma2.getSession(config);
          }
        }]);
        return Enigma2;
      }();
      return Enigma;
    });
  }
});

// src/auth/rpcClient.ts
var import_enigma = __toESM(require_enigma());

// src/errors.ts
var GenericError = class extends Error {
  constructor(error) {
    switch (typeof error) {
      case "string":
        super(error);
        break;
      case "object":
        super(error?.error);
        Object.assign(this, error);
        break;
      default:
        super("UnkownError");
    }
    this.name = this.constructor.name;
  }
};
var AuthenticationError = class extends GenericError {
};
var ConnectionError = class extends GenericError {
};
var CustomError = class extends GenericError {
};
var AuthorizationError = class extends GenericError {
};

// src/utils/utils.ts
var getUrl = (host, isSecure = void 0) => {
  let actualHost;
  let actualIsSecure;
  try {
    const url = new URL(host);
    actualHost = url.host + url.pathname;
    actualIsSecure = url.protocol.toLowerCase() === "https:";
  } catch (error) {
    actualHost = host;
    actualIsSecure = isSecure ?? true;
  }
  const urlString = `${actualIsSecure ? "https:" : "http:"}//${actualHost}`.replace(/([^:])(\/\/+)/g, "$1/");
  return new URL(urlString);
};
var isBrowser = (() => typeof window !== "undefined" && ("WebSocket" in window || "MozWebSocket" in window))();
var generateWebsocketUrl = async (appId, rest, config, appendAccessToken = null) => {
  const accessToken = appendAccessToken || isBrowser;
  const hostUrl = getUrl(config.host, config?.isSecure);
  const wssProtocol = hostUrl.protocol === "http:" || hostUrl.protocol === "ws:" ? "ws:" : "wss:";
  const url = `${wssProtocol}//${hostUrl.host}/app/${appId}`;
  if (config.authType === "APIKey" /* APIKey */ || config.authType === "OAuth2" /* OAuth2 */ && !accessToken) {
    return url;
  }
  if (["WebIntegration" /* WebIntegration */, "JWTAuth" /* JWTAuth */].includes(config.authType)) {
    let { csrfToken } = config;
    if (!csrfToken) {
      const res = await rest("/csrf-token");
      csrfToken = res.headers.get("qlik-csrf-token");
    }
    const webUrl = `${url}?qlik-csrf-token=${csrfToken}&qlik-web-integration-id=${config.webIntegrationId}`;
    return webUrl;
  }
  if (config.authType === "OAuth2" /* OAuth2 */ && accessToken) {
    const resp = await (await rest("/oauth/token", {
      method: "POST",
      body: JSON.stringify({
        subject_token: config.apiKey,
        subject_token_type: "urn:ietf:params:oauth:token-type:access_token",
        grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
        purpose: "websocket",
        redirect_uri: config.redirectUri,
        client_id: config.clientId
      })
    })).json();
    const webUrl = `${url}?accessToken=${resp.access_token}`;
    return webUrl;
  }
  throw new CustomError(
    `${"Not implemented" /* NOT_IMPLEMENTED */}: function generateWebsocketUrl for AuthType: ${config.authType}`
  );
};

// src/auth/restClient.ts
function use(intercept) {
  const interceptArr = Array.isArray(intercept) ? intercept : [intercept];
  this.handlers = this.handlers.concat(interceptArr);
}
var RestClient = class {
  constructor(config) {
    this.interceptors = {
      request: {
        handlers: [],
        use
      },
      response: {
        handlers: [],
        use
      }
    };
    this.restClientInstance = async (request, init = {}) => {
      let urlString = request.toString();
      let endPoint;
      let modifiedRequest = [request, init];
      for (const handler of this.interceptors.request.handlers) {
        const restRequestHandler = handler;
        modifiedRequest = await restRequestHandler(modifiedRequest);
      }
      if (!(urlString.toLowerCase().startsWith("http://") || urlString.toLowerCase().startsWith("https://"))) {
        [endPoint] = modifiedRequest;
        const excludeApiV1Prefix = ["/api/v1", "/login/jwt-session", "/oauth/token", "/oauth/authorize", "/oauth/revoke"];
        const shouldAddPrefix = !excludeApiV1Prefix.some((prefix) => endPoint.startsWith(prefix));
        endPoint = `${shouldAddPrefix ? "/api/v1/" : ""}${endPoint}`;
        urlString = getUrl(`${config.host}${endPoint}`, config?.isSecure).href;
      } else {
        endPoint = getUrl(urlString).pathname;
      }
      let headers = init?.headers || {};
      if (config.authType === "APIKey" /* APIKey */) {
        headers = {
          Authorization: `Bearer ${config.apiKey}`,
          ...headers
        };
      } else if (config.authType === "WebIntegration" /* WebIntegration */ || config.authType === "JWTAuth" /* JWTAuth */ || config.authType === "None" /* None */) {
        let { csrfToken } = config;
        const initMethod = init?.method ?? "get";
        if (!csrfToken && initMethod.toUpperCase() !== "GET") {
          const csrf = await this.restClientInstance("/csrf-token");
          csrfToken = csrf.headers["qlik-csrf-token"];
        }
        headers = {
          "qlik-web-integration-id": config.webIntegrationId,
          ...headers
        };
        if (csrfToken) {
          headers["qlik-csrf-token"] = csrfToken;
        }
      } else if (config.authType === "OAuth2" /* OAuth2 */) {
        if (config.clientSecret && endPoint === "/oauth/token") {
          headers = {
            ...headers,
            Authorization: `Basic ${Buffer.from(
              `${config.clientId}:${config.clientSecret}`
            ).toString("base64")}`
          };
        } else if (config.apiKey && endPoint !== "/oauth/token") {
          headers = {
            Authorization: `Bearer ${config.apiKey}`,
            ...headers
          };
        }
      }
      const version = "0.18.0";
      const anyBody = init?.body;
      const hasFormDataBody = anyBody?.append !== void 0;
      const initUpdatedHeaders = {
        ...init,
        redirect: "follow",
        headers: {
          ...hasFormDataBody ? {} : { "content-type": "application/json" },
          "User-Agent": `qlik-sdk-typescript/${version}`,
          ...headers
        }
      };
      let response;
      try {
        response = await this.restClientInstance.fetch(urlString, {
          ...initUpdatedHeaders,
          credentials: "include"
        });
        for (const handler of this.interceptors.response.handlers) {
          const restResponseHandler = handler;
          response = await restResponseHandler(response);
        }
      } catch (err) {
        throw new ConnectionError({
          error: `${"Connection Error" /* NO_RESPONSE */}: ${config.host}`,
          ...err
        });
      }
      if (response.ok) {
        return response;
      }
      let errorData;
      try {
        errorData = await response.json();
      } catch (_) {
      }
      const errorObject = {
        statusText: response.statusText,
        status: response.status,
        ...errorData || {}
      };
      if (response.status === 401) {
        if (config.authType === "OAuth2" /* OAuth2 */) {
          throw new AuthorizationError({
            error: "Failed to authorize using OAuth" /* FAILED_AUTH_OAUTH */,
            ...errorObject
          });
        } else if (config.authType === "APIKey" /* APIKey */) {
          throw new AuthenticationError({
            error: "Failed to authenticate host using api-key" /* FAILED_AUTH_API_KEY */,
            ...errorObject
          });
        } else {
          throw new AuthenticationError({
            error: "Unauthenticated",
            ...errorObject
          });
        }
      }
      const { errors } = errorObject;
      throw new CustomError({
        error: errors ? errors[0]?.title : errorObject?.statusText || "Unknown Error",
        ...errorObject
      });
    };
    this.restClientInstance.interceptors = this.interceptors;
    this.restClientInstance.fetch = this.restClientInstance.fetch || (false ? fetch : window.fetch.bind(window));
  }
};

// src/auth/rpcClient.ts
var WS = false ? null : WebSocket;
function use2(intercept) {
  const interceptArr = Array.isArray(intercept) ? intercept : [intercept];
  this.handlers = this.handlers.concat(interceptArr);
}
var RpcClient = class {
  constructor(config, rest) {
    this.interceptors = {
      request: {
        handlers: [],
        use: use2
      },
      response: {
        handlers: [],
        use: use2
      }
    };
    this.sessions = {};
    this.config = config;
    this.rest = rest ?? new RestClient(config).restClientInstance;
  }
  async rpc(appId) {
    const { url, createSocket } = await this.buildUrlAndCreateSocket(appId);
    const createSession = () => {
      const session = import_enigma.default.create({
        schema: {
          structs: {
            Global: {},
            Doc: {},
            GenericMeasure: {},
            GenericVariable: {},
            GenericBookmark: {},
            GenericDimension: {},
            GenericObject: {},
            Field: {}
          }
        },
        url,
        createSocket,
        protocol: { delta: false }
      });
      session.intercept.response = this.interceptors.response.handlers;
      session.intercept.request = this.interceptors.request.handlers;
      return session;
    };
    this.sessions[url.toString()] = this.sessions[url.toString()] || createSession();
    return this.sessions[url.toString()];
  }
  async buildUrlAndCreateSocket(appId) {
    const url = await generateWebsocketUrl(appId, this.rest, this.config);
    let createSocket;
    if (this.config.authType === "APIKey" /* APIKey */ || this.config.authType === "OAuth2" /* OAuth2 */ && !isBrowser) {
      createSocket = (wsUrl) => new WS(wsUrl, {
        headers: { Authorization: `Bearer ${this.config.apiKey}` }
      });
    } else {
      createSocket = (wsUrl) => new WS(wsUrl);
    }
    return { url, createSocket };
  }
};
export {
  RpcClient as default
};
