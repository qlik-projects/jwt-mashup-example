// src/errors.ts
var GenericError = class extends Error {
  constructor(error) {
    switch (typeof error) {
      case "string":
        super(error);
        break;
      case "object":
        super(error?.error);
        Object.assign(this, error);
        break;
      default:
        super("UnkownError");
    }
    this.name = this.constructor.name;
  }
};
var AuthenticationError = class extends GenericError {
};
var ConnectionError = class extends GenericError {
};
var CustomError = class extends GenericError {
};
var AuthorizationError = class extends GenericError {
};

// src/utils/utils.ts
var getUrl = (host, isSecure = void 0) => {
  let actualHost;
  let actualIsSecure;
  try {
    const url = new URL(host);
    actualHost = url.host + url.pathname;
    actualIsSecure = url.protocol.toLowerCase() === "https:";
  } catch (error) {
    actualHost = host;
    actualIsSecure = isSecure ?? true;
  }
  const urlString = `${actualIsSecure ? "https:" : "http:"}//${actualHost}`.replace(/([^:])(\/\/+)/g, "$1/");
  return new URL(urlString);
};
var isBrowser = (() => typeof window !== "undefined" && ("WebSocket" in window || "MozWebSocket" in window))();

// src/auth/restClient.ts
function use(intercept) {
  const interceptArr = Array.isArray(intercept) ? intercept : [intercept];
  this.handlers = this.handlers.concat(interceptArr);
}
var RestClient = class {
  constructor(config) {
    this.interceptors = {
      request: {
        handlers: [],
        use
      },
      response: {
        handlers: [],
        use
      }
    };
    this.restClientInstance = async (request, init = {}) => {
      let urlString = request.toString();
      let endPoint;
      let modifiedRequest = [request, init];
      for (const handler of this.interceptors.request.handlers) {
        const restRequestHandler = handler;
        modifiedRequest = await restRequestHandler(modifiedRequest);
      }
      if (!(urlString.toLowerCase().startsWith("http://") || urlString.toLowerCase().startsWith("https://"))) {
        [endPoint] = modifiedRequest;
        const excludeApiV1Prefix = ["/api/v1", "/login/jwt-session", "/oauth/token", "/oauth/authorize", "/oauth/revoke"];
        const shouldAddPrefix = !excludeApiV1Prefix.some((prefix) => endPoint.startsWith(prefix));
        endPoint = `${shouldAddPrefix ? "/api/v1/" : ""}${endPoint}`;
        urlString = getUrl(`${config.host}${endPoint}`, config?.isSecure).href;
      } else {
        endPoint = getUrl(urlString).pathname;
      }
      let headers = init?.headers || {};
      if (config.authType === "APIKey" /* APIKey */) {
        headers = {
          Authorization: `Bearer ${config.apiKey}`,
          ...headers
        };
      } else if (config.authType === "WebIntegration" /* WebIntegration */ || config.authType === "JWTAuth" /* JWTAuth */ || config.authType === "None" /* None */) {
        let { csrfToken } = config;
        const initMethod = init?.method ?? "get";
        if (!csrfToken && initMethod.toUpperCase() !== "GET") {
          const csrf = await this.restClientInstance("/csrf-token");
          csrfToken = csrf.headers["qlik-csrf-token"];
        }
        headers = {
          "qlik-web-integration-id": config.webIntegrationId,
          ...headers
        };
        if (csrfToken) {
          headers["qlik-csrf-token"] = csrfToken;
        }
      } else if (config.authType === "OAuth2" /* OAuth2 */) {
        if (config.clientSecret && endPoint === "/oauth/token") {
          headers = {
            ...headers,
            Authorization: `Basic ${Buffer.from(
              `${config.clientId}:${config.clientSecret}`
            ).toString("base64")}`
          };
        } else if (config.apiKey && endPoint !== "/oauth/token") {
          headers = {
            Authorization: `Bearer ${config.apiKey}`,
            ...headers
          };
        }
      }
      const version = "0.18.0";
      const anyBody = init?.body;
      const hasFormDataBody = anyBody?.append !== void 0;
      const initUpdatedHeaders = {
        ...init,
        redirect: "follow",
        headers: {
          ...hasFormDataBody ? {} : { "content-type": "application/json" },
          "User-Agent": `qlik-sdk-typescript/${version}`,
          ...headers
        }
      };
      let response;
      try {
        response = await this.restClientInstance.fetch(urlString, {
          ...initUpdatedHeaders,
          credentials: "include"
        });
        for (const handler of this.interceptors.response.handlers) {
          const restResponseHandler = handler;
          response = await restResponseHandler(response);
        }
      } catch (err) {
        throw new ConnectionError({
          error: `${"Connection Error" /* NO_RESPONSE */}: ${config.host}`,
          ...err
        });
      }
      if (response.ok) {
        return response;
      }
      let errorData;
      try {
        errorData = await response.json();
      } catch (_) {
      }
      const errorObject = {
        statusText: response.statusText,
        status: response.status,
        ...errorData || {}
      };
      if (response.status === 401) {
        if (config.authType === "OAuth2" /* OAuth2 */) {
          throw new AuthorizationError({
            error: "Failed to authorize using OAuth" /* FAILED_AUTH_OAUTH */,
            ...errorObject
          });
        } else if (config.authType === "APIKey" /* APIKey */) {
          throw new AuthenticationError({
            error: "Failed to authenticate host using api-key" /* FAILED_AUTH_API_KEY */,
            ...errorObject
          });
        } else {
          throw new AuthenticationError({
            error: "Unauthenticated",
            ...errorObject
          });
        }
      }
      const { errors } = errorObject;
      throw new CustomError({
        error: errors ? errors[0]?.title : errorObject?.statusText || "Unknown Error",
        ...errorObject
      });
    };
    this.restClientInstance.interceptors = this.interceptors;
    this.restClientInstance.fetch = this.restClientInstance.fetch || (false ? fetch : window.fetch.bind(window));
  }
};
export {
  RestClient as default
};
