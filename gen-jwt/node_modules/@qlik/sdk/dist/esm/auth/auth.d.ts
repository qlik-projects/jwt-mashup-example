import { Config } from '../types/types.js';
import { TokenResponse } from '../utils/oauthUtils.js';
import { RestClientInstance } from './restClient.js';
import { RpcClientInstance } from './rpcClient.js';
/**
 * @remarks
 * Auth.ts is a typescript module included in qlik-sdk for implementing authentication
 * and authorization in browsers and node.js web apps
 * (Note: 'autoRedirect' field will be set to false if missing)
 *
 * @param config - required configuration
 *
 * @returns an instance of the Auth module.
 * @example
 * ```ts
 * import Auth from '@qlik/sdk/auth';
 * const config: Config =  {
 *   authType: AuthType.WebIntegration,
 *   host: 'my-tenant.qlikcloud.com',
 *   webIntegrationId: '<webintegrationId>',
 * };
 *
 * const auth = new Auth(config);
 *
 * if(!auth.isAuthenticated()){
 *   auth.authenticate();
 * }
 * ```
 */
export default class Auth {
    /** config object reference for the module instance */
    config: Config;
    /** rest client object reference for the module instance */
    rest: RestClientInstance;
    rpc: RpcClientInstance;
    /** generates the websocket url
    * @param appId - the app Id
    * @param appendAccessToken - override for appending the accessToken only OAuth
    *
    * @returns websocket Url.
    * @example
    * ```ts
    * const wssUrl = await auth.generateWebsocketUrl(appId);
    * // create an enigma instance
    * const global = await enigma
    *  .create({
    *    schema,
    *    url: wssUrl,
    *  })
    *  .open();
    *```
    */
    generateWebsocketUrl: (appId: string, appendAccessToken?: boolean) => Promise<string>;
    private rpcClient;
    private verifier?;
    private state?;
    constructor(config: Config);
    /**
     * Get access
     * For WebIntegration:
     * Navigates to the login page and redirects back to the current page after login
     */
    authenticate(): void;
    /**
     * checks authentication status using the "/users/me" endpoint
     */
    isAuthenticated(): Promise<boolean>;
    /**
     * checks authorization status using the "/users/me" endpoint
     */
    isAuthorized(): Promise<boolean>;
    /**
     * invalidate the current session
     */
    deauthenticate(): void;
    /**
     * getSessionCookie - For JWTAuth:
     * function helper for getting the session cookies.
     */
    getSessionCookie(): Promise<Response>;
    /**
     * exchange credentials with token against the authorization server
     * @param url - The callback url with query parameters
     */
    authorize(url?: string): Promise<any>;
    /**
     * deauthorize
     * revokes the Auth instance oauth token
     */
    deauthorize(): Promise<void>;
    /**
     * refreshToken
     * method helper for refreshing the token
     */
    refreshToken(): Promise<TokenResponse>;
    /**
     * generateAuthorizationUrl
     * @param state - for validating against potential CSRF attacks,
     * will generate and use a random string if not set
     */
    generateAuthorizationUrl(state?: string): Promise<{
        url: string;
        verifier: string;
        state: string;
    }>;
}
