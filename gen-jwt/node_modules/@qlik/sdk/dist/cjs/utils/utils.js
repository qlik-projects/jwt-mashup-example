var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  generateRandomString: () => generateRandomString,
  generateWebsocketUrl: () => generateWebsocketUrl,
  getUrl: () => getUrl,
  isBrowser: () => isBrowser,
  validateClaims: () => validateClaims,
  validateConfig: () => validateConfig,
  validateSigningOptions: () => validateSigningOptions
});
module.exports = __toCommonJS(utils_exports);
var import_errors = require("../errors.js");
var import_types = require("../types/types.js");
const getUrl = (host, isSecure = void 0) => {
  let actualHost;
  let actualIsSecure;
  try {
    const url = new URL(host);
    actualHost = url.host + url.pathname;
    actualIsSecure = url.protocol.toLowerCase() === "https:";
  } catch (error) {
    actualHost = host;
    actualIsSecure = isSecure ?? true;
  }
  const urlString = `${actualIsSecure ? "https:" : "http:"}//${actualHost}`.replace(/([^:])(\/\/+)/g, "$1/");
  return new URL(urlString);
};
const validateConfig = (config) => {
  const basicRequiredKeys = ["host", "authType"];
  for (const basicRequiredKey of basicRequiredKeys) {
    if (!(basicRequiredKey in config)) {
      throw new import_errors.CustomError(
        `${import_errors.CustomErrorMsg.MISSING_REQUIRED_PROPERTY}: ${basicRequiredKey}`
      );
    }
  }
  if (!config.host || config.host === "") {
    throw new import_errors.CustomError(import_errors.CustomErrorMsg.EMPTY_HOST);
  }
  if (!(config.authType in import_types.AuthType)) {
    throw new import_errors.CustomError(
      `${import_errors.CustomErrorMsg.UNSUPPORTED_AUTH_TYPE}: ${config.authType}`
    );
  }
  const authTypeRequiredKeys = {
    [import_types.AuthType.WebIntegration]: ["webIntegrationId"],
    [import_types.AuthType.APIKey]: ["apiKey"],
    [import_types.AuthType.JWTAuth]: ["fetchToken", "webIntegrationId"],
    [import_types.AuthType.OAuth2]: ["clientId"],
    [import_types.AuthType.None]: []
  };
  const stringProperties = /* @__PURE__ */ new Set(["webIntegrationId", "apiKey", "clientId", "clientSecret", "redirectUri"]);
  for (const requiredKey of authTypeRequiredKeys[config.authType]) {
    if (!(requiredKey in config) || stringProperties.has(requiredKey) && !config[requiredKey]) {
      throw new import_errors.CustomError(
        `${import_errors.CustomErrorMsg.MISSING_REQUIRED_PROPERTY}: ${requiredKey}`
      );
    }
  }
  const authTypeOptionalKeys = {
    [import_types.AuthType.APIKey]: ["isSecure"],
    [import_types.AuthType.WebIntegration]: ["autoRedirect", "csrfToken", "isSecure"],
    [import_types.AuthType.OAuth2]: ["clientSecret", "redirectUri", "scopes", "refreshToken", "isSecure"],
    [import_types.AuthType.JWTAuth]: ["csrfToken", "isSecure"]
  };
  const allowedKeys = /* @__PURE__ */ new Set([
    ...basicRequiredKeys,
    ...authTypeRequiredKeys[config.authType],
    ...authTypeOptionalKeys[config.authType] ?? []
  ]);
  for (const configKey of Object.keys(config)) {
    if (!allowedKeys.has(configKey)) {
      throw new import_errors.CustomError(
        `${import_errors.CustomErrorMsg.UNSUPPORTED_PROPERTY} ${configKey} for authType ${config.authType}`
      );
    }
  }
  if (config.authType === import_types.AuthType.OAuth2) {
    if (!config.clientSecret && !config.redirectUri) {
      throw new import_errors.CustomError(
        `${import_errors.CustomErrorMsg.MISSING_REQUIRED_PROPERTY}: clientSecret or redirectUri`
      );
    }
  }
};
const validateProps = (obj, requiredProps) => {
  for (let i = 0; i < requiredProps.length; i += 1) {
    if (!(requiredProps[i] in obj) || obj[requiredProps[i]] === "") {
      throw new import_errors.CustomError(
        `${import_errors.CustomErrorMsg.MISSING_REQUIRED_PROPERTY}: ${requiredProps[i]}`
      );
    }
  }
};
const validateClaims = (claims) => {
  const requiredProps = [
    "jti",
    "sub",
    "subType",
    "email",
    "email_verified",
    "groups"
  ];
  validateProps(claims, requiredProps);
};
const validateSigningOptions = (options) => {
  if (options.algorithm !== "RS256" || options.audience !== "qlik.api/login/jwt-session") {
    throw new import_errors.CustomError(
      `${import_errors.CustomErrorMsg.MISSING_REQUIRED_PROPERTY}: algorithm and audience missing or must have values 'RS256', respectively 'qlik.api/login/jwt-session'`
    );
  }
  const requiredProps = ["keyid", "issuer", "expiresIn", "notBefore"];
  validateProps(options, requiredProps);
};
const generateRandomString = (length) => {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < length; i += 1) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
};
const isBrowser = (() => typeof window !== "undefined" && ("WebSocket" in window || "MozWebSocket" in window))();
const generateWebsocketUrl = async (appId, rest, config, appendAccessToken = null) => {
  const accessToken = appendAccessToken || isBrowser;
  const hostUrl = getUrl(config.host, config?.isSecure);
  const wssProtocol = hostUrl.protocol === "http:" || hostUrl.protocol === "ws:" ? "ws:" : "wss:";
  const url = `${wssProtocol}//${hostUrl.host}/app/${appId}`;
  if (config.authType === import_types.AuthType.APIKey || config.authType === import_types.AuthType.OAuth2 && !accessToken) {
    return url;
  }
  if ([import_types.AuthType.WebIntegration, import_types.AuthType.JWTAuth].includes(config.authType)) {
    let { csrfToken } = config;
    if (!csrfToken) {
      const res = await rest("/csrf-token");
      csrfToken = res.headers.get("qlik-csrf-token");
    }
    const webUrl = `${url}?qlik-csrf-token=${csrfToken}&qlik-web-integration-id=${config.webIntegrationId}`;
    return webUrl;
  }
  if (config.authType === import_types.AuthType.OAuth2 && accessToken) {
    const resp = await (await rest("/oauth/token", {
      method: "POST",
      body: JSON.stringify({
        subject_token: config.apiKey,
        subject_token_type: "urn:ietf:params:oauth:token-type:access_token",
        grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
        purpose: "websocket",
        redirect_uri: config.redirectUri,
        client_id: config.clientId
      })
    })).json();
    const webUrl = `${url}?accessToken=${resp.access_token}`;
    return webUrl;
  }
  throw new import_errors.CustomError(
    `${import_errors.CustomErrorMsg.NOT_IMPLEMENTED}: function generateWebsocketUrl for AuthType: ${config.authType}`
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  generateRandomString,
  generateWebsocketUrl,
  getUrl,
  isBrowser,
  validateClaims,
  validateConfig,
  validateSigningOptions
});
