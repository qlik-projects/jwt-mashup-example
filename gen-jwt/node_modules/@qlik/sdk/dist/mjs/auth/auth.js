import {
  AuthenticationError,
  AuthenticationErrorMsg,
  CustomError
} from "../errors.js";
import { AuthType } from "../types/types.js";
import { generateAuthorizationUrl } from "../utils/oauthUtils.js";
import {
  isBrowser,
  getUrl,
  validateConfig,
  generateWebsocketUrl
} from "../utils/utils.js";
import RestClient from "./restClient.js";
import RpcClient from "./rpcClient.js";
const OnlyWebIntegrationError = new CustomError(
  "Only supported for AuthType.WebIntegration"
);
class Auth {
  constructor(config) {
    if (!config.host) {
      throw new CustomError("Empty host in config");
    }
    let host;
    let isSecure;
    let getUrlError;
    try {
      const tenantUrl = getUrl(config.host, config.isSecure);
      host = tenantUrl.host;
      isSecure = tenantUrl.protocol === "https:";
    } catch (error) {
      getUrlError = error;
    }
    if (getUrlError) {
      throw new CustomError("Invalid host in config");
    }
    if (config.isSecure !== void 0 && config.isSecure !== isSecure) {
      throw new CustomError("Ambiguous config, mismatch for host and isSecure");
    }
    this.config = {
      ...config,
      host,
      isSecure
    };
    if (this.config.authType === AuthType.WebIntegration && !("autoRedirect" in this.config)) {
      this.config.autoRedirect = false;
    }
    if (this.config.authType === AuthType.OAuth2) {
      this.config.scopes = [
        "user_default",
        ...(this.config?.scopes ?? []).filter((v) => v !== "user_default")
      ];
    }
    validateConfig(this.config);
    const restClient = new RestClient(this.config);
    this.rpcClient = new RpcClient(this.config);
    this.rpc = (appId) => this.rpcClient.rpc(appId);
    Object.assign(this.rpc, { interceptors: this.rpcClient.interceptors });
    this.rest = restClient.restClientInstance;
    this.generateWebsocketUrl = (appId, appendAccessToken) => generateWebsocketUrl(appId, this.rest, this.config, appendAccessToken);
    if (this.config.autoRedirect) {
      this.isAuthenticated().then((loggedIn) => {
        if (!loggedIn) {
          this.authenticate();
        }
      });
    }
  }
  authenticate() {
    if (this.config.authType !== AuthType.WebIntegration) {
      throw OnlyWebIntegrationError;
    }
    const loginUrl = getUrl(`${this.config.host}/login`, this.config.isSecure);
    loginUrl.searchParams.append("returnto", window.location.href);
    loginUrl.searchParams.append(
      "qlik-web-integration-id",
      this.config.webIntegrationId
    );
    window.location.assign(loginUrl.href);
  }
  async isAuthenticated() {
    return this.rest("/users/me").then((res) => res.status === 200).catch(() => false);
  }
  async isAuthorized() {
    return this.isAuthenticated();
  }
  deauthenticate() {
    if (this.config.authType !== AuthType.WebIntegration) {
      throw OnlyWebIntegrationError;
    }
    const logoutUrl = getUrl(`${this.config.host}/logout`, this.config.isSecure);
    logoutUrl.searchParams.append("returnto", window.location.href);
    window.location.assign(logoutUrl.href);
  }
  async getSessionCookie() {
    const signedToken = await this.config.fetchToken();
    const resp = await this.rest.fetch(
      getUrl(`${this.config.host}/login/jwt-session`, this.config?.isSecure).toString(),
      {
        method: "POST",
        credentials: "include",
        mode: "cors",
        headers: {
          "content-type": "application/json",
          Authorization: `Bearer ${signedToken}`,
          "qlik-web-integration-id": this.config.webIntegrationId
        }
      }
    );
    if (resp.status !== 200) {
      throw new AuthenticationError(AuthenticationErrorMsg.UNAUTHENTICATED);
    }
    return resp;
  }
  async authorize(url) {
    const urlParams = url ? Object.fromEntries(new URL(url).searchParams.entries()) : {};
    const code = urlParams?.code;
    const state = urlParams?.state;
    const error = urlParams?.error;
    if (error) {
      throw new CustomError({
        error,
        error_code: urlParams?.error_code,
        error_description: urlParams?.error_description,
        error_detail: urlParams?.error_detail,
        error_uri: urlParams?.error_uri
      });
    }
    if (isBrowser) {
      this.state = localStorage.getItem(`${this.config.clientId}_state`) ?? "";
      this.verifier = localStorage.getItem(`${this.config.clientId}_verifier`) ?? "";
      localStorage.removeItem(`${this.config.clientId}_state`);
      localStorage.removeItem(`${this.config.clientId}_verifier`);
    }
    if (this.state && state !== this.state) {
      throw new Error("The received state parameter does not match the original state value");
    }
    const body = JSON.stringify({
      grant_type: code ? "authorization_code" : "client_credentials",
      scope: this.config.scopes.join(" "),
      ...code ? { code } : {},
      ...this.config.redirectUri ? { redirect_uri: this.config.redirectUri } : {},
      ...this.verifier ? { code_verifier: this.verifier } : {},
      client_id: this.config.clientId
    });
    const response = await this.rest("/oauth/token", { method: "POST", body });
    const responseJson = await response.json();
    this.config.apiKey = responseJson.access_token;
    this.config.refreshToken = responseJson?.refresh_token;
    return responseJson;
  }
  async deauthorize() {
    await this.rest(
      "/oauth/revoke",
      {
        method: "POST",
        body: JSON.stringify({
          token: this.config.apiKey,
          token_type_hint: "access_token"
        })
      }
    );
    this.config.apiKey = "";
  }
  async refreshToken() {
    if (this.config.authType !== AuthType.OAuth2 || !this.config.scopes.includes("offline_access") || !this.config.refreshToken) {
      throw new CustomError(
        "Method only available for AuthType OAuth2, that have offline_access scope"
      );
    }
    const response = await this.rest(
      "/oauth/token",
      {
        method: "POST",
        body: JSON.stringify({
          grant_type: "refresh_token",
          refresh_token: this.config.refreshToken
        })
      }
    ).then((resp) => resp.json());
    this.config.apiKey = response.access_token;
    this.config.refreshToken = response.refresh_token;
    return response;
  }
  async generateAuthorizationUrl(state) {
    const { url, verifier, state: usedState } = await generateAuthorizationUrl(this.config, state);
    this.verifier = verifier;
    this.state = usedState;
    if (isBrowser) {
      localStorage.setItem(`${this.config.clientId}_state`, this.state);
      localStorage.setItem(`${this.config.clientId}_verifier`, this.verifier);
    }
    return { url, verifier, state: usedState };
  }
}
export {
  Auth as default
};
