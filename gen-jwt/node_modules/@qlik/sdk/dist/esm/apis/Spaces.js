import Auth from "../auth/auth.js";
class Space {
  constructor({
    createdAt,
    createdBy,
    description,
    id,
    links,
    meta,
    name,
    ownerId,
    tenantId,
    type,
    updatedAt,
    ...rest
  }, auth) {
    this.auth = auth;
    this.createdAt = createdAt;
    this.createdBy = createdBy;
    this.description = description;
    this.id = id;
    if (links instanceof SpaceLinks) {
      this.links = links;
    } else {
      this.links = new SpaceLinks(links, this.auth);
    }
    if (meta !== void 0 && meta !== null) {
      if (meta instanceof SpaceMeta) {
        this.meta = meta;
      } else {
        this.meta = new SpaceMeta(meta, this.auth);
      }
    }
    this.name = name;
    this.ownerId = ownerId;
    this.tenantId = tenantId;
    this.type = type;
    this.updatedAt = updatedAt;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  async getAssignments(queryParams = { limit: 10 }) {
    const response = await this.auth.rest(
      `${"/spaces/{spaceId}/assignments".replace("{spaceId}", this.id ?? "")}?${Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => `${k}=${v}`).join("&")}`,
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new Assignments(responseJson, this.auth);
  }
  async createAssignment(data) {
    const response = await this.auth.rest(
      "/spaces/{spaceId}/assignments".replace("{spaceId}", this.id ?? ""),
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    return new Assignment(responseJson, this.auth);
  }
  async delete() {
    await this.auth.rest(
      "/spaces/{spaceId}".replace("{spaceId}", this.id ?? ""),
      {
        method: "DELETE"
      }
    );
  }
  async patch(data) {
    const response = await this.auth.rest(
      "/spaces/{spaceId}".replace("{spaceId}", this.id ?? ""),
      {
        method: "PATCH",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    Object.keys(responseJson).forEach((key) => {
      if (this[key]) {
        this[key] = responseJson[key];
      }
    });
    return this;
  }
  async set(data) {
    const response = await this.auth.rest(
      "/spaces/{spaceId}".replace("{spaceId}", this.id ?? ""),
      {
        method: "PUT",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    Object.keys(responseJson).forEach((key) => {
      if (this[key]) {
        this[key] = responseJson[key];
      }
    });
    return this;
  }
}
class Assignment {
  constructor({
    assigneeId,
    createdAt,
    createdBy,
    id,
    links,
    roles,
    spaceId,
    tenantId,
    type,
    updatedAt,
    updatedBy,
    ...rest
  }, auth) {
    this.auth = auth;
    this.assigneeId = assigneeId;
    this.createdAt = createdAt;
    this.createdBy = createdBy;
    this.id = id;
    if (links instanceof AssignmentLinks) {
      this.links = links;
    } else {
      this.links = new AssignmentLinks(links, this.auth);
    }
    this.roles = roles;
    this.spaceId = spaceId;
    this.tenantId = tenantId;
    this.type = type;
    this.updatedAt = updatedAt;
    this.updatedBy = updatedBy;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class AssignmentCreate {
  constructor({
    assigneeId,
    roles,
    type,
    ...rest
  }, auth) {
    this.auth = auth;
    this.assigneeId = assigneeId;
    this.roles = roles;
    this.type = type;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class AssignmentLinks {
  constructor({
    self,
    space,
    ...rest
  }, auth) {
    this.auth = auth;
    if (self instanceof Link) {
      this.self = self;
    } else {
      this.self = new Link(self, this.auth);
    }
    if (space !== void 0 && space !== null) {
      if (space instanceof Link) {
        this.space = space;
      } else {
        this.space = new Link(space, this.auth);
      }
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class AssignmentUpdate {
  constructor({
    roles,
    ...rest
  }, auth) {
    this.auth = auth;
    this.roles = roles;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class Assignments {
  constructor({
    data,
    links,
    meta,
    ...rest
  }, auth) {
    this.auth = auth;
    if (data !== void 0 && data !== null) {
      if (data.length > 0 && data[0] instanceof Assignment) {
        this.data = data;
      } else {
        this.data = data.map((element) => new Assignment(element, this.auth));
      }
    }
    if (links !== void 0 && links !== null) {
      if (links instanceof AssignmentsLinks) {
        this.links = links;
      } else {
        this.links = new AssignmentsLinks(links, this.auth);
      }
    }
    if (meta !== void 0 && meta !== null) {
      if (meta instanceof AssignmentsMeta) {
        this.meta = meta;
      } else {
        this.meta = new AssignmentsMeta(meta, this.auth);
      }
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class AssignmentsLinks {
  constructor({
    next,
    prev,
    self,
    ...rest
  }, auth) {
    this.auth = auth;
    if (next !== void 0 && next !== null) {
      if (next instanceof Link) {
        this.next = next;
      } else {
        this.next = new Link(next, this.auth);
      }
    }
    if (prev !== void 0 && prev !== null) {
      if (prev instanceof Link) {
        this.prev = prev;
      } else {
        this.prev = new Link(prev, this.auth);
      }
    }
    if (self instanceof Link) {
      this.self = self;
    } else {
      this.self = new Link(self, this.auth);
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class AssignmentsMeta {
  constructor({
    count,
    ...rest
  }, auth) {
    this.auth = auth;
    this.count = count;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class Link {
  constructor({
    href,
    ...rest
  }, auth) {
    this.auth = auth;
    this.href = href;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class SpaceCreate {
  constructor({
    description,
    name,
    type,
    ...rest
  }, auth) {
    this.auth = auth;
    this.description = description;
    this.name = name;
    this.type = type;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class SpaceLinks {
  constructor({
    assignments,
    self,
    ...rest
  }, auth) {
    this.auth = auth;
    if (assignments instanceof Link) {
      this.assignments = assignments;
    } else {
      this.assignments = new Link(assignments, this.auth);
    }
    if (self instanceof Link) {
      this.self = self;
    } else {
      this.self = new Link(self, this.auth);
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class SpaceMeta {
  constructor({
    actions,
    assignableRoles,
    roles,
    ...rest
  }, auth) {
    this.auth = auth;
    this.actions = actions;
    this.assignableRoles = assignableRoles;
    this.roles = roles;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class SpacePatch {
  constructor({
    ...rest
  }, auth) {
    this.auth = auth;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class SpaceTypes {
  constructor({
    data,
    ...rest
  }, auth) {
    this.auth = auth;
    this.data = data;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class SpaceUpdate {
  constructor({
    description,
    name,
    ownerId,
    ...rest
  }, auth) {
    this.auth = auth;
    this.description = description;
    this.name = name;
    this.ownerId = ownerId;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class SpacesClass {
  constructor({
    data,
    links,
    meta,
    ...rest
  }, auth) {
    this.auth = auth;
    if (data !== void 0 && data !== null) {
      if (data.length > 0 && data[0] instanceof Space) {
        this.data = data;
      } else {
        this.data = data.map((element) => new Space(element, this.auth));
      }
    }
    if (links !== void 0 && links !== null) {
      if (links instanceof SpacesLinks) {
        this.links = links;
      } else {
        this.links = new SpacesLinks(links, this.auth);
      }
    }
    if (meta !== void 0 && meta !== null) {
      if (meta instanceof SpacesMeta) {
        this.meta = meta;
      } else {
        this.meta = new SpacesMeta(meta, this.auth);
      }
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class SpacesLinks {
  constructor({
    next,
    prev,
    self,
    ...rest
  }, auth) {
    this.auth = auth;
    if (next !== void 0 && next !== null) {
      if (next instanceof Link) {
        this.next = next;
      } else {
        this.next = new Link(next, this.auth);
      }
    }
    if (prev !== void 0 && prev !== null) {
      if (prev instanceof Link) {
        this.prev = prev;
      } else {
        this.prev = new Link(prev, this.auth);
      }
    }
    if (self instanceof Link) {
      this.self = self;
    } else {
      this.self = new Link(self, this.auth);
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class SpacesMeta {
  constructor({
    count,
    personalSpace,
    ...rest
  }, auth) {
    this.auth = auth;
    this.count = count;
    if (personalSpace !== void 0 && personalSpace !== null) {
      if (personalSpace instanceof SpacesMetaPersonalSpace) {
        this.personalSpace = personalSpace;
      } else {
        this.personalSpace = new SpacesMetaPersonalSpace(personalSpace, this.auth);
      }
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class SpacesMetaPersonalSpace {
  constructor({
    actions,
    resourceType,
    ...rest
  }, auth) {
    this.auth = auth;
    this.actions = actions;
    this.resourceType = resourceType;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class Spaces {
  constructor(config) {
    this.config = config instanceof Auth ? config.config : config;
    this.auth = config instanceof Auth ? config : new Auth(config);
  }
  async getTypes() {
    const response = await this.auth.rest(
      "/spaces/types",
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new SpaceTypes(responseJson, this.auth);
  }
  async deleteAssignment(assignmentId, spaceId) {
    await this.auth.rest(
      "/spaces/{spaceId}/assignments/{assignmentId}".replace("{assignmentId}", assignmentId).replace("{spaceId}", spaceId),
      {
        method: "DELETE"
      }
    );
  }
  async getAssignment(assignmentId, spaceId) {
    const response = await this.auth.rest(
      "/spaces/{spaceId}/assignments/{assignmentId}".replace("{assignmentId}", assignmentId).replace("{spaceId}", spaceId),
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new Assignment(responseJson, this.auth);
  }
  async setAssignment(assignmentId, spaceId, data) {
    const response = await this.auth.rest(
      "/spaces/{spaceId}/assignments/{assignmentId}".replace("{assignmentId}", assignmentId).replace("{spaceId}", spaceId),
      {
        method: "PUT",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    return new Assignment(responseJson, this.auth);
  }
  async get(spaceId) {
    const response = await this.auth.rest(
      "/spaces/{spaceId}".replace("{spaceId}", spaceId),
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new Space(responseJson, this.auth);
  }
  async getSpaces(queryParams = { limit: 10 }) {
    const response = await this.auth.rest(
      `/spaces?${Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => `${k}=${v}`).join("&")}`,
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new SpacesClass(responseJson, this.auth);
  }
  async create(data) {
    const response = await this.auth.rest(
      "/spaces",
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    return new Space(responseJson, this.auth);
  }
}
export {
  Assignment,
  AssignmentCreate,
  AssignmentLinks,
  AssignmentUpdate,
  Assignments,
  AssignmentsLinks,
  AssignmentsMeta,
  Link,
  Space,
  SpaceCreate,
  SpaceLinks,
  SpaceMeta,
  SpacePatch,
  SpaceTypes,
  SpaceUpdate,
  Spaces,
  SpacesClass,
  SpacesLinks,
  SpacesMeta,
  SpacesMetaPersonalSpace
};
