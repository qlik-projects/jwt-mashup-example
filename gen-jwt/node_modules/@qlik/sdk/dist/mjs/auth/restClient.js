
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
import {
  AuthenticationError,
  AuthenticationErrorMsg,
  AuthorizationError,
  AuthorizationErrorMsg,
  ConnectionError,
  ConnectionErrorMsg,
  CustomError
} from "../errors.js";
import {
  AuthType
} from "../types/types.js";
import { getUrl } from "../utils/utils.js";
function use(intercept) {
  const interceptArr = Array.isArray(intercept) ? intercept : [intercept];
  this.handlers = this.handlers.concat(interceptArr);
}
class RestClient {
  constructor(config) {
    this.interceptors = {
      request: {
        handlers: [],
        use
      },
      response: {
        handlers: [],
        use
      }
    };
    this.restClientInstance = async (request, init = {}) => {
      let urlString = request.toString();
      let endPoint;
      let modifiedRequest = [request, init];
      for (const handler of this.interceptors.request.handlers) {
        const restRequestHandler = handler;
        modifiedRequest = await restRequestHandler(modifiedRequest);
      }
      if (!(urlString.toLowerCase().startsWith("http://") || urlString.toLowerCase().startsWith("https://"))) {
        [endPoint] = modifiedRequest;
        const excludeApiV1Prefix = ["/api/v1", "/login/jwt-session", "/oauth/token", "/oauth/authorize", "/oauth/revoke"];
        const shouldAddPrefix = !excludeApiV1Prefix.some((prefix) => endPoint.startsWith(prefix));
        endPoint = `${shouldAddPrefix ? "/api/v1/" : ""}${endPoint}`;
        urlString = getUrl(`${config.host}${endPoint}`, config?.isSecure).href;
      } else {
        endPoint = getUrl(urlString).pathname;
      }
      let headers = init?.headers || {};
      if (config.authType === AuthType.APIKey) {
        headers = {
          Authorization: `Bearer ${config.apiKey}`,
          ...headers
        };
      } else if (config.authType === AuthType.WebIntegration || config.authType === AuthType.JWTAuth || config.authType === AuthType.None) {
        let { csrfToken } = config;
        const initMethod = init?.method ?? "get";
        if (!csrfToken && initMethod.toUpperCase() !== "GET") {
          const csrf = await this.restClientInstance("/csrf-token");
          csrfToken = csrf.headers["qlik-csrf-token"];
        }
        headers = {
          "qlik-web-integration-id": config.webIntegrationId,
          ...headers
        };
        if (csrfToken) {
          headers["qlik-csrf-token"] = csrfToken;
        }
      } else if (config.authType === AuthType.OAuth2) {
        if (config.clientSecret && endPoint === "/oauth/token") {
          headers = {
            ...headers,
            Authorization: `Basic ${Buffer.from(
              `${config.clientId}:${config.clientSecret}`
            ).toString("base64")}`
          };
        } else if (config.apiKey && endPoint !== "/oauth/token") {
          headers = {
            Authorization: `Bearer ${config.apiKey}`,
            ...headers
          };
        }
      }
      const version = "0.18.0";
      const anyBody = init?.body;
      const hasFormDataBody = anyBody?.append !== void 0;
      const initUpdatedHeaders = {
        ...init,
        redirect: "follow",
        headers: {
          ...hasFormDataBody ? {} : { "content-type": "application/json" },
          "User-Agent": `qlik-sdk-typescript/${version}`,
          ...headers
        }
      };
      let response;
      try {
        response = await this.restClientInstance.fetch(urlString, {
          ...initUpdatedHeaders,
          credentials: "include"
        });
        for (const handler of this.interceptors.response.handlers) {
          const restResponseHandler = handler;
          response = await restResponseHandler(response);
        }
      } catch (err) {
        throw new ConnectionError({
          error: `${ConnectionErrorMsg.NO_RESPONSE}: ${config.host}`,
          ...err
        });
      }
      if (response.ok) {
        return response;
      }
      let errorData;
      try {
        errorData = await response.json();
      } catch (_) {
      }
      const errorObject = {
        statusText: response.statusText,
        status: response.status,
        ...errorData || {}
      };
      if (response.status === 401) {
        if (config.authType === AuthType.OAuth2) {
          throw new AuthorizationError({
            error: AuthorizationErrorMsg.FAILED_AUTH_OAUTH,
            ...errorObject
          });
        } else if (config.authType === AuthType.APIKey) {
          throw new AuthenticationError({
            error: AuthenticationErrorMsg.FAILED_AUTH_API_KEY,
            ...errorObject
          });
        } else {
          throw new AuthenticationError({
            error: "Unauthenticated",
            ...errorObject
          });
        }
      }
      const { errors } = errorObject;
      throw new CustomError({
        error: errors ? errors[0]?.title : errorObject?.statusText || "Unknown Error",
        ...errorObject
      });
    };
    this.restClientInstance.interceptors = this.interceptors;
    this.restClientInstance.fetch = this.restClientInstance.fetch || (true ? fetch : window.fetch.bind(window));
  }
}
export {
  RestClient as default
};
