var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Webhooks_exports = {};
__export(Webhooks_exports, {
  Delivery: () => Delivery,
  DeliveryList: () => DeliveryList,
  DeliveryListLinks: () => DeliveryListLinks,
  DeliveryRequest: () => DeliveryRequest,
  DeliveryResponse: () => DeliveryResponse,
  EventType: () => EventType,
  EventTypes: () => EventTypes,
  Link: () => Link,
  Webhook: () => Webhook,
  WebhookDef: () => WebhookDef,
  WebhookList: () => WebhookList,
  WebhookListLinks: () => WebhookListLinks,
  WebhookPatch: () => WebhookPatch,
  Webhooks: () => Webhooks
});
module.exports = __toCommonJS(Webhooks_exports);
var import_auth = __toESM(require("../auth/auth.js"));
class Webhook {
  constructor({
    createdAt,
    createdByUserId,
    description,
    disabledReason,
    disabledReasonCode,
    enabled,
    eventTypes,
    filter,
    headers,
    id,
    level,
    name,
    ownerId,
    secret,
    updatedAt,
    updatedByUserId,
    url,
    ...rest
  }, auth) {
    this.auth = auth;
    this.createdAt = createdAt;
    this.createdByUserId = createdByUserId;
    this.description = description;
    this.disabledReason = disabledReason;
    this.disabledReasonCode = disabledReasonCode;
    this.enabled = enabled;
    this.eventTypes = eventTypes;
    this.filter = filter;
    this.headers = headers;
    this.id = id;
    this.level = level;
    this.name = name;
    this.ownerId = ownerId;
    this.secret = secret;
    this.updatedAt = updatedAt;
    this.updatedByUserId = updatedByUserId;
    this.url = url;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
  async getDeliveries(queryParams = { limit: 20, sort: "-triggeredAt" }) {
    const response = await this.auth.rest(
      `${"/webhooks/{id}/deliveries".replace("{id}", this.id ?? "")}?${Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => `${k}=${v}`).join("&")}`,
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new DeliveryList(responseJson, this.auth);
  }
  async delete() {
    await this.auth.rest(
      "/webhooks/{id}".replace("{id}", this.id ?? ""),
      {
        method: "DELETE"
      }
    );
  }
  async patch(WebhookPatchData) {
    await this.auth.rest(
      "/webhooks/{id}".replace("{id}", this.id ?? ""),
      {
        method: "PATCH",
        body: JSON.stringify(WebhookPatchData)
      }
    );
  }
  async set(data) {
    const response = await this.auth.rest(
      "/webhooks/{id}".replace("{id}", this.id ?? ""),
      {
        method: "PUT",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    Object.keys(responseJson).forEach((key) => {
      if (this[key]) {
        this[key] = responseJson[key];
      }
    });
    return this;
  }
}
class Delivery {
  constructor({
    eventType,
    id,
    request,
    response,
    status,
    statusMessage,
    triggeredAt,
    webhookId,
    ...rest
  }, auth) {
    this.auth = auth;
    this.eventType = eventType;
    this.id = id;
    if (request !== void 0 && request !== null) {
      if (request instanceof DeliveryRequest) {
        this.request = request;
      } else {
        this.request = new DeliveryRequest(request, this.auth);
      }
    }
    if (response !== void 0 && response !== null) {
      if (response instanceof DeliveryResponse) {
        this.response = response;
      } else {
        this.response = new DeliveryResponse(response, this.auth);
      }
    }
    this.status = status;
    this.statusMessage = statusMessage;
    this.triggeredAt = triggeredAt;
    this.webhookId = webhookId;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class DeliveryList {
  constructor({
    data,
    links,
    ...rest
  }, auth) {
    this.auth = auth;
    if (data !== void 0 && data !== null) {
      if (data.length > 0 && data[0] instanceof Delivery) {
        this.data = data;
      } else {
        this.data = data.map((element) => new Delivery(element, this.auth));
      }
    }
    if (links !== void 0 && links !== null) {
      if (links instanceof DeliveryListLinks) {
        this.links = links;
      } else {
        this.links = new DeliveryListLinks(links, this.auth);
      }
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class DeliveryListLinks {
  constructor({
    next,
    prev,
    self,
    ...rest
  }, auth) {
    this.auth = auth;
    if (next !== void 0 && next !== null) {
      if (next instanceof Link) {
        this.next = next;
      } else {
        this.next = new Link(next, this.auth);
      }
    }
    if (prev !== void 0 && prev !== null) {
      if (prev instanceof Link) {
        this.prev = prev;
      } else {
        this.prev = new Link(prev, this.auth);
      }
    }
    if (self !== void 0 && self !== null) {
      if (self instanceof Link) {
        this.self = self;
      } else {
        this.self = new Link(self, this.auth);
      }
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class DeliveryRequest {
  constructor({
    body,
    headers,
    url,
    ...rest
  }, auth) {
    this.auth = auth;
    this.body = body;
    this.headers = headers;
    this.url = url;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class DeliveryResponse {
  constructor({
    body,
    headers,
    statusCode,
    ...rest
  }, auth) {
    this.auth = auth;
    this.body = body;
    this.headers = headers;
    this.statusCode = statusCode;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class EventType {
  constructor({
    description,
    levels,
    name,
    title,
    ...rest
  }, auth) {
    this.auth = auth;
    this.description = description;
    this.levels = levels;
    this.name = name;
    this.title = title;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class EventTypes {
  constructor({
    data,
    ...rest
  }, auth) {
    this.auth = auth;
    if (data !== void 0 && data !== null) {
      if (data.length > 0 && data[0] instanceof EventType) {
        this.data = data;
      } else {
        this.data = data.map((element) => new EventType(element, this.auth));
      }
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class Link {
  constructor({
    href,
    ...rest
  }, auth) {
    this.auth = auth;
    this.href = href;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class WebhookDef {
  constructor({
    description,
    enabled,
    eventTypes,
    filter,
    headers,
    level,
    name,
    ownerId,
    secret,
    url,
    ...rest
  }, auth) {
    this.auth = auth;
    this.description = description;
    this.enabled = enabled;
    this.eventTypes = eventTypes;
    this.filter = filter;
    this.headers = headers;
    this.level = level;
    this.name = name;
    this.ownerId = ownerId;
    this.secret = secret;
    this.url = url;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class WebhookList {
  constructor({
    data,
    links,
    ...rest
  }, auth) {
    this.auth = auth;
    if (data !== void 0 && data !== null) {
      if (data.length > 0 && data[0] instanceof Webhook) {
        this.data = data;
      } else {
        this.data = data.map((element) => new Webhook(element, this.auth));
      }
    }
    if (links !== void 0 && links !== null) {
      if (links instanceof WebhookListLinks) {
        this.links = links;
      } else {
        this.links = new WebhookListLinks(links, this.auth);
      }
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class WebhookListLinks {
  constructor({
    next,
    prev,
    self,
    ...rest
  }, auth) {
    this.auth = auth;
    if (next !== void 0 && next !== null) {
      if (next instanceof Link) {
        this.next = next;
      } else {
        this.next = new Link(next, this.auth);
      }
    }
    if (prev !== void 0 && prev !== null) {
      if (prev instanceof Link) {
        this.prev = prev;
      } else {
        this.prev = new Link(prev, this.auth);
      }
    }
    if (self !== void 0 && self !== null) {
      if (self instanceof Link) {
        this.self = self;
      } else {
        this.self = new Link(self, this.auth);
      }
    }
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class WebhookPatch {
  constructor({
    op,
    path,
    value,
    ...rest
  }, auth) {
    this.auth = auth;
    this.op = op;
    this.path = path;
    this.value = value;
    if (rest) {
      Object.keys(rest).forEach((prop) => {
        this[prop] = rest[prop];
      });
    }
  }
}
class Webhooks {
  constructor(config) {
    this.config = config instanceof import_auth.default ? config.config : config;
    this.auth = config instanceof import_auth.default ? config : new import_auth.default(config);
  }
  async getEventTypes() {
    const response = await this.auth.rest(
      "/webhooks/event-types",
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new EventTypes(responseJson, this.auth);
  }
  async resend(deliveryId, id) {
    const response = await this.auth.rest(
      "/webhooks/{id}/deliveries/{deliveryId}/actions/resend".replace("{deliveryId}", deliveryId).replace("{id}", id),
      {
        method: "POST"
      }
    );
    const responseJson = await response.json();
    return new Delivery(responseJson, this.auth);
  }
  async getDeliverie(deliveryId, id) {
    const response = await this.auth.rest(
      "/webhooks/{id}/deliveries/{deliveryId}".replace("{deliveryId}", deliveryId).replace("{id}", id),
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new Delivery(responseJson, this.auth);
  }
  async get(id) {
    const response = await this.auth.rest(
      "/webhooks/{id}".replace("{id}", id),
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new Webhook(responseJson, this.auth);
  }
  async getWebhooks(queryParams = { limit: 20, sort: "-createdAt" }) {
    const response = await this.auth.rest(
      `/webhooks?${Object.entries(queryParams).filter(([, v]) => v !== void 0).map(([k, v]) => `${k}=${v}`).join("&")}`,
      {
        method: "GET"
      }
    );
    const responseJson = await response.json();
    return new WebhookList(responseJson, this.auth);
  }
  async create(data) {
    const response = await this.auth.rest(
      "/webhooks",
      {
        method: "POST",
        body: JSON.stringify(data)
      }
    );
    const responseJson = await response.json();
    return new Webhook(responseJson, this.auth);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Delivery,
  DeliveryList,
  DeliveryListLinks,
  DeliveryRequest,
  DeliveryResponse,
  EventType,
  EventTypes,
  Link,
  Webhook,
  WebhookDef,
  WebhookList,
  WebhookListLinks,
  WebhookPatch,
  Webhooks
});
