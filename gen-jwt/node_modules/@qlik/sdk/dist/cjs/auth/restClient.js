var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var restClient_exports = {};
__export(restClient_exports, {
  default: () => RestClient
});
module.exports = __toCommonJS(restClient_exports);
var import_errors = require("../errors.js");
var import_types = require("../types/types.js");
var import_utils = require("../utils/utils.js");
function use(intercept) {
  const interceptArr = Array.isArray(intercept) ? intercept : [intercept];
  this.handlers = this.handlers.concat(interceptArr);
}
class RestClient {
  constructor(config) {
    this.interceptors = {
      request: {
        handlers: [],
        use
      },
      response: {
        handlers: [],
        use
      }
    };
    this.restClientInstance = async (request, init = {}) => {
      let urlString = request.toString();
      let endPoint;
      let modifiedRequest = [request, init];
      for (const handler of this.interceptors.request.handlers) {
        const restRequestHandler = handler;
        modifiedRequest = await restRequestHandler(modifiedRequest);
      }
      if (!(urlString.toLowerCase().startsWith("http://") || urlString.toLowerCase().startsWith("https://"))) {
        [endPoint] = modifiedRequest;
        const excludeApiV1Prefix = ["/api/v1", "/login/jwt-session", "/oauth/token", "/oauth/authorize", "/oauth/revoke"];
        const shouldAddPrefix = !excludeApiV1Prefix.some((prefix) => endPoint.startsWith(prefix));
        endPoint = `${shouldAddPrefix ? "/api/v1/" : ""}${endPoint}`;
        urlString = (0, import_utils.getUrl)(`${config.host}${endPoint}`, config?.isSecure).href;
      } else {
        endPoint = (0, import_utils.getUrl)(urlString).pathname;
      }
      let headers = init?.headers || {};
      if (config.authType === import_types.AuthType.APIKey) {
        headers = {
          Authorization: `Bearer ${config.apiKey}`,
          ...headers
        };
      } else if (config.authType === import_types.AuthType.WebIntegration || config.authType === import_types.AuthType.JWTAuth || config.authType === import_types.AuthType.None) {
        let { csrfToken } = config;
        const initMethod = init?.method ?? "get";
        if (!csrfToken && initMethod.toUpperCase() !== "GET") {
          const csrf = await this.restClientInstance("/csrf-token");
          csrfToken = csrf.headers["qlik-csrf-token"];
        }
        headers = {
          "qlik-web-integration-id": config.webIntegrationId,
          ...headers
        };
        if (csrfToken) {
          headers["qlik-csrf-token"] = csrfToken;
        }
      } else if (config.authType === import_types.AuthType.OAuth2) {
        if (config.clientSecret && endPoint === "/oauth/token") {
          headers = {
            ...headers,
            Authorization: `Basic ${Buffer.from(
              `${config.clientId}:${config.clientSecret}`
            ).toString("base64")}`
          };
        } else if (config.apiKey && endPoint !== "/oauth/token") {
          headers = {
            Authorization: `Bearer ${config.apiKey}`,
            ...headers
          };
        }
      }
      const version = "0.18.0";
      const anyBody = init?.body;
      const hasFormDataBody = anyBody?.append !== void 0;
      const initUpdatedHeaders = {
        ...init,
        redirect: "follow",
        headers: {
          ...hasFormDataBody ? {} : { "content-type": "application/json" },
          "User-Agent": `qlik-sdk-typescript/${version}`,
          ...headers
        }
      };
      let response;
      try {
        response = await this.restClientInstance.fetch(urlString, {
          ...initUpdatedHeaders,
          credentials: "include"
        });
        for (const handler of this.interceptors.response.handlers) {
          const restResponseHandler = handler;
          response = await restResponseHandler(response);
        }
      } catch (err) {
        throw new import_errors.ConnectionError({
          error: `${import_errors.ConnectionErrorMsg.NO_RESPONSE}: ${config.host}`,
          ...err
        });
      }
      if (response.ok) {
        return response;
      }
      let errorData;
      try {
        errorData = await response.json();
      } catch (_) {
      }
      const errorObject = {
        statusText: response.statusText,
        status: response.status,
        ...errorData || {}
      };
      if (response.status === 401) {
        if (config.authType === import_types.AuthType.OAuth2) {
          throw new import_errors.AuthorizationError({
            error: import_errors.AuthorizationErrorMsg.FAILED_AUTH_OAUTH,
            ...errorObject
          });
        } else if (config.authType === import_types.AuthType.APIKey) {
          throw new import_errors.AuthenticationError({
            error: import_errors.AuthenticationErrorMsg.FAILED_AUTH_API_KEY,
            ...errorObject
          });
        } else {
          throw new import_errors.AuthenticationError({
            error: "Unauthenticated",
            ...errorObject
          });
        }
      }
      const { errors } = errorObject;
      throw new import_errors.CustomError({
        error: errors ? errors[0]?.title : errorObject?.statusText || "Unknown Error",
        ...errorObject
      });
    };
    this.restClientInstance.interceptors = this.interceptors;
    this.restClientInstance.fetch = this.restClientInstance.fetch || (true ? fetch : window.fetch.bind(window));
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
