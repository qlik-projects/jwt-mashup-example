import type { JwtPayload, SignOptions } from 'jsonwebtoken';
export declare enum AuthType {
    /** bearer authentication - using token representing a user in your tenant */
    APIKey = "APIKey",
    /** browser authentication with redirect */
    WebIntegration = "WebIntegration",
    /** browser authorization with JWT */
    JWTAuth = "JWTAuth",
    /** oauth authentication */
    OAuth2 = "OAuth2",
    /** None - for environments that do nor require authentications (ex: extensions) */
    None = "None"
}
/** Config object
 * @param host - host address of your tenant
 * @param isSecure - whether to use secure protocol
 * @param authType - the authentication type
 * @param apiKey - token representing a user in your tenant
 * @param webIntegrationId - webIntegrationId
 * @param csrfToken - csrfToken
 * @param refreshToken - refreshToken used with the `offline_access` scope
 * @param autoRedirect - automatically attempt to authenticate
 * @param fetchToken - callback function part of the config for fetching the signed token
 * @param clientId - oauth clientId
 * @param clientSecret - oauth clientSecret
 * @param scopes - oauth scopes, always includes 'user_default'
 * @param redirectUri - oauth redirect destination after successful authorization
 *
 * @see {@link https://qlik.dev/basics/authentication-options#web-integrations} for more details on web-integrations
 */
export type Config = {
    host: URL['host'];
    isSecure?: boolean;
    authType: AuthType;
    apiKey?: string;
    webIntegrationId?: string;
    csrfToken?: string;
    refreshToken?: string;
    autoRedirect?: boolean;
    fetchToken?: () => Promise<string>;
    clientId?: string;
    clientSecret?: string;
    scopes?: string[];
    redirectUri?: string;
};
/** Claims object - used in for signing the JWT token */
export type ClaimsAndOptions = {
    /** (JWT ID) claim provides a unique identifier for the JWT. */
    jti?: JwtPayload['jti'];
    /** The main identifier (aka subject) of the user. */
    sub: JwtPayload['sub'];
    /** The type of identifier the sub represents. user is the only applicable value. */
    subType: string;
    /** The friendly name to apply to the user. */
    name: string;
    /** The email address of the user. */
    email: string;
    /** Source has verified that the email address belongs to the subject. */
    email_verified: boolean;
    /** groups */
    groups: Array<string>;
    /** expressed in seconds or a string describing a time span [zeit/ms](https://github.com/zeit/ms.js).  Eg: 60, "2 days", "10h", "7d" */
    expiresIn: SignOptions['expiresIn'];
    /** expressed in seconds or a string describing a time span [zeit/ms](https://github.com/zeit/ms.js).  Eg: 60, "2 days", "10h", "7d" */
    notBefore: SignOptions['notBefore'];
    /** the keyid defined from  the JWT identity provider configuration. */
    keyid: SignOptions['keyid'];
    /** the issuer defined from  the JWT identity provider configuration. */
    issuer: SignOptions['issuer'];
    /** The algorithm must be set to "RS256" */
    algorithm?: SignOptions['algorithm'];
    /** the audience must be set to "qlik.api/login/jwt-session" */
    audience?: SignOptions['audience'];
};
export type Interceptors = {
    request: InterceptorsHandler<RestRequestInterceptor | RpcRequestInterceptor>;
    response: InterceptorsHandler<RestResponseInterceptor | RpcRequestInterceptor>;
};
export type InterceptorsHandler<T> = {
    handlers: Array<T>;
    /** Adds a handler in the request/response handlers list
     * @param intercept - interceptor or array of interceptors
     */
    use(interceptors: T | Array<T>): void;
};
/** Rest Request interceptor
 * @example
 * ```ts
 * const addHeader: RequestInfo = ([url, config]) => {
 *  return [url, {
 *    ...config,
 *    headers: {
        ...headers,
        'x-qlik-sdk': 'TS v1.0.0'
      }
 *  }];
 * }
 * auth.rest.interceptors.request.use(addHeader);
 * ```
*/
export type RestRequestInterceptor = {
    (RequestInfo: any): RequestInfo | PromiseLike<RequestInfo>;
};
/** Rest Response interceptor
 * @example
 * ```ts
 * const logger: Response = (resp) => {
 *  console.log(await resp.clone().json());
 *  return resp;
 * }
 * auth.rest.interceptors.response.use(logger);
 * ```
 */
export type RestResponseInterceptor = {
    (Response: any): Response | PromiseLike<Response>;
};
/** RPC Request interceptor
 * @example
 * ```ts
 * const logRequest: RpcRequestInterceptor = {
 *    onFulfilled: (session, req) => {
 *      console.log(req);
 *      return req;
 *    },
 *  };
 *};
 * ```
 */
export type RpcRequestInterceptor = {
    onFulfilled?(session: RpcSession, request: RpcRequestObject, result: any): Promise<RpcRequestObject>;
};
/** RPC Response interceptor
 * @example
 * ```ts
 * const logError: RpcResponseInterceptor = {
 *    onRejected: (session, req, err) => {
 *      throw err;
 *    },
 *  };
 *};
 * ```
 */
export type RpcResponseInterceptor = {
    onRejected?(session: RpcSession, request: RpcRequestObject, error: Error): Promise<RpcResponseObject>;
    onFulfilled?(session: RpcSession, request: RpcRequestObject, result: any): any;
};
export type RpcRequestObject = {
    /** version of JSON-RPC defaults to 2.0 */
    jsonrpc?: string;
    /** Identifier established by the initiator of the request */
    id?: string;
    /** name of the engine method. */
    method: string;
    /** target of the method. */
    handle: number;
    /** If set to true, the engine returns delta values. The default value is false. */
    delta?: boolean;
    /** the parameters can be provided by name through an object or by position through an array */
    params: Array<any> | string;
    /** returns default and empty values. */
    return_empty?: boolean;
};
export type RpcResponseObject = {
    /** ID of the backend object. */
    id: string;
    /** QIX type of the backend object. Can for example be "Doc" or "GenericVariable". */
    type: string;
    /** Custom type of the backend object, if defined in qInfo. */
    genericType: string;
    /** The QIX Engine session object. */
    session: RpcSession;
    /** Handle of the backend object. */
    handle: number;
    /** represents the returned value from engine */
    result: {
        qReturn: any;
    } | null;
};
export type RpcSession = {
    /** Establishes the websocket against the configured URL and returns the Global instance. */
    open(): Promise<RpcResponseObject>;
    /** Closes the websocket and cleans up internal caches */
    close(): Promise<void>;
    /** Function used to send data on the RPC socket. */
    send(request: RpcRequestObject): Promise<RpcResponseObject>;
    /** Listen to events */
    on(event: 'opened' | 'closed' | 'suspended' | 'resumed' | string, listener: (() => void) | ((data: any) => void) | ((type: string, data: any) => void)): void;
};
